{"version":3,"sources":["../src/index.ts","../src/request-error-handler.ts","../src/request-error.ts","../src/interceptor-manager.ts","../src/request-handler.ts","../src/api-handler.ts"],"sourcesContent":["import { RequestHandler } from './request-handler';\nimport type { APIResponse, FetchResponse, RequestHandlerConfig } from './types';\n\n/**\n * Simple wrapper for request fetching.\n * It abstracts the creation of RequestHandler, making it easy to perform API requests.\n *\n * @param {string | URL | globalThis.Request} url - Request URL.\n * @param {Object} config - Configuration object for the request handler.\n * @returns {Promise<Response | RequestResponse>} Response Data.\n */\nexport async function fetchf<Response = APIResponse>(\n  url: string,\n  config: RequestHandlerConfig = {},\n): Promise<Response & FetchResponse<Response>> {\n  return new RequestHandler(config).request<Response>(\n    url,\n    config.body || config.data || config.params,\n    config,\n  );\n}\n\nexport * from './types';\nexport * from './api-handler';\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport class RequestErrorHandler {\n  /**\n   * Logger Class\n   *\n   * @type {*}\n   * @memberof RequestErrorHandler\n   */\n  protected logger: any;\n\n  /**\n   * Error Service Class\n   *\n   * @type {*}\n   * @memberof RequestErrorHandler\n   */\n  public requestErrorService: any;\n\n  public constructor(logger: any, requestErrorService: any) {\n    this.logger = logger;\n    this.requestErrorService = requestErrorService;\n  }\n\n  /**\n   * Process and Error\n   *\n   * @param {*} error Error instance or message\n   * @throws          Request error context\n   * @returns {void}\n   */\n  public process(error: string | Error): void {\n    if (this.logger?.warn) {\n      this.logger.warn('API ERROR', error);\n    }\n\n    let errorContext = error;\n\n    if (typeof error === 'string') {\n      errorContext = new Error(error);\n    }\n\n    if (this.requestErrorService) {\n      if (typeof this.requestErrorService.process !== 'undefined') {\n        this.requestErrorService.process(errorContext);\n      } else if (typeof this.requestErrorService === 'function') {\n        this.requestErrorService(errorContext);\n      }\n    }\n  }\n}\n","import type { RequestConfig } from './types';\n\nexport class RequestError extends Error {\n  response: Response;\n  request: RequestConfig;\n\n  constructor(message: string, requestInfo: RequestConfig, response: Response) {\n    super(message);\n\n    this.name = 'RequestError';\n    this.message = message;\n    this.request = requestInfo;\n    this.response = response;\n\n    // Clean stack trace\n    Error.captureStackTrace(this, RequestError);\n  }\n}\n","import type {\n  BaseRequestHandlerConfig,\n  FetchResponse,\n  RequestResponse,\n} from './types';\nimport type {\n  RequestInterceptor,\n  ResponseInterceptor,\n} from './types/interceptor-manager';\n\n/**\n * Applies a series of request interceptors to the provided configuration.\n * @param {BaseRequestHandlerConfig} config - The initial request configuration.\n * @param {RequestInterceptor | RequestInterceptor[]} interceptors - The request interceptor function(s) to apply.\n * @returns {Promise<BaseRequestHandlerConfig>} - The modified request configuration.\n */\nexport async function interceptRequest(\n  config: BaseRequestHandlerConfig,\n  interceptors: RequestInterceptor | RequestInterceptor[],\n): Promise<BaseRequestHandlerConfig> {\n  if (!interceptors) {\n    return config;\n  }\n\n  const interceptorList = Array.isArray(interceptors)\n    ? interceptors\n    : [interceptors];\n\n  let interceptedConfig = { ...config };\n\n  for (const interceptor of interceptorList) {\n    interceptedConfig = await interceptor(interceptedConfig);\n  }\n\n  return interceptedConfig;\n}\n\n/**\n * Applies a series of response interceptors to the provided response.\n * @param {FetchResponse<ResponseData>} response - The initial response object.\n * @param {ResponseInterceptor | ResponseInterceptor[]} interceptors - The response interceptor function(s) to apply.\n * @returns {Promise<RequestResponse<ResponseData>>} - The modified response object.\n */\nexport async function interceptResponse<ResponseData = unknown>(\n  response: FetchResponse<ResponseData>,\n  interceptors: ResponseInterceptor | ResponseInterceptor[],\n): Promise<RequestResponse<ResponseData>> {\n  if (!interceptors) {\n    return response;\n  }\n\n  const interceptorList = Array.isArray(interceptors)\n    ? interceptors\n    : [interceptors];\n\n  let interceptedResponse = response;\n\n  for (const interceptor of interceptorList) {\n    interceptedResponse = await interceptor(interceptedResponse);\n  }\n\n  return interceptedResponse;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { RequestErrorHandler } from './request-error-handler';\nimport type {\n  ErrorHandlingStrategy,\n  RequestHandlerConfig,\n  RequestConfig,\n  RequestError as RequestErrorResponse,\n  FetcherInstance,\n  Method,\n  RequestConfigHeaders,\n  RetryOptions,\n  FetchResponse,\n  ExtendedResponse,\n} from './types/request-handler';\nimport type {\n  APIResponse,\n  QueryParams,\n  QueryParamsOrBody,\n  UrlPathParams,\n} from './types/api-handler';\nimport { RequestError } from './request-error';\nimport { interceptRequest, interceptResponse } from './interceptor-manager';\n\n/**\n * Generic Request Handler\n * It creates an Request Fetcher instance and handles requests within that instance\n * It handles errors depending on a chosen error handling strategy\n */\nexport class RequestHandler {\n  /**\n   * @var requestInstance Provider's instance\n   */\n  public requestInstance: FetcherInstance;\n\n  /**\n   * @var baseURL Base API url\n   */\n  public baseURL: string = '';\n\n  /**\n   * @var timeout Request timeout\n   */\n  public timeout: number = 30000;\n\n  /**\n   * @var cancellable Response cancellation\n   */\n  public cancellable: boolean = false;\n\n  /**\n   * @var rejectCancelled Whether to reject cancelled requests or not\n   */\n  public rejectCancelled: boolean = false;\n\n  /**\n   * @var strategy Request timeout\n   */\n  public strategy: ErrorHandlingStrategy = 'reject';\n\n  /**\n   * @var method Request method\n   */\n  public method: Method | string = 'get';\n\n  /**\n   * @var flattenResponse Response flattening\n   */\n  public flattenResponse: boolean = false;\n\n  /**\n   * @var defaultResponse Response flattening\n   */\n  public defaultResponse: any = null;\n\n  /**\n   * @var fetcher Request Fetcher instance\n   */\n  protected fetcher: FetcherInstance;\n\n  /**\n   * @var logger Logger\n   */\n  protected logger: any;\n\n  /**\n   * @var requestErrorService HTTP error service\n   */\n  protected onError: any;\n\n  /**\n   * @var requestsQueue    Queue of requests\n   */\n  protected requestsQueue: WeakMap<object, AbortController>;\n\n  /**\n   * Request Handler Config\n   */\n  protected retry: RetryOptions = {\n    retries: 0,\n    delay: 1000,\n    maxDelay: 30000,\n    backoff: 1.5,\n\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n    retryOn: [\n      408, // Request Timeout\n      409, // Conflict\n      425, // Too Early\n      429, // Too Many Requests\n      500, // Internal Server Error\n      502, // Bad Gateway\n      503, // Service Unavailable\n      504, // Gateway Timeout\n    ],\n\n    shouldRetry: async () => true,\n  };\n\n  /**\n   * Request Handler Config\n   */\n  public config: RequestHandlerConfig;\n\n  /**\n   * Creates an instance of RequestHandler.\n   *\n   * @param {Object} config - Configuration object for the request.\n   * @param {string} config.baseURL - The base URL for the request.\n   * @param {Object} config.endpoints - An object containing endpoint definitions.\n   * @param {number} config.timeout - You can set the timeout for particular request in milliseconds.\n   * @param {number} config.cancellable - If true, the previous requests will be automatically cancelled.\n   * @param {number} config.rejectCancelled - If true and request is set to cancellable, a cancelled request promise will be rejected. By default, instead of rejecting the promise, defaultResponse is returned.\n   * @param {number} config.timeout - Request timeout\n   * @param {string} config.strategy - Error Handling Strategy\n   * @param {string} config.flattenResponse - Whether to flatten response \"data\" object within \"data\" one\n   * @param {*} config.defaultResponse - Default response when there is no data or when endpoint fails depending on the chosen strategy. It's \"null\" by default\n   * @param {Object} [config.retry] - Options for retrying requests.\n   * @param {number} [config.retry.retries=0] - Number of retry attempts. No retries by default.\n   * @param {number} [config.retry.delay=1000] - Initial delay between retries in milliseconds.\n   * @param {number} [config.retry.backoff=1.5] - Exponential backoff factor.\n   * @param {number[]} [config.retry.retryOn=[502, 504, 408]] - HTTP status codes to retry on.\n   * @param {RequestInterceptor|RequestInterceptor[]} [config.onRequest] - Optional request interceptor function or an array of functions.\n   * These functions will be called with the request configuration object before the request is made. Can be used to modify or log the request configuration.\n   * @param {ResponseInterceptor|ResponseInterceptor[]} [config.onResponse] - Optional response interceptor function or an array of functions.\n   * These functions will be called with the response object after the response is received. an be used to modify or log the response data.\n   * @param {Function} [config.onError] - Optional callback function for handling errors.\n   * @param {Object} [config.headers] - Optional default headers to include in every request.\n   * @param {Object} config.fetcher - The Axios (or any other) instance to use for making requests.\n   * @param {*} config.logger - Instance of custom logger. Either class or an object similar to \"console\". Console is used by default.\n   */\n  public constructor({\n    fetcher = null,\n    timeout = null,\n    rejectCancelled = false,\n    strategy = null,\n    flattenResponse = null,\n    defaultResponse = {},\n    logger = null,\n    onError = null,\n    ...config\n  }: RequestHandlerConfig) {\n    this.fetcher = fetcher;\n    this.timeout =\n      timeout !== null && timeout !== undefined ? timeout : this.timeout;\n    this.strategy =\n      strategy !== null && strategy !== undefined ? strategy : this.strategy;\n    this.cancellable = config.cancellable || this.cancellable;\n    this.rejectCancelled = rejectCancelled || this.rejectCancelled;\n    this.flattenResponse =\n      flattenResponse !== null && flattenResponse !== undefined\n        ? flattenResponse\n        : this.flattenResponse;\n    this.defaultResponse = defaultResponse;\n    this.logger = logger || (globalThis ? globalThis.console : null) || null;\n    this.onError = onError;\n    this.requestsQueue = new WeakMap();\n    this.baseURL = config.baseURL || config.apiUrl || '';\n    this.method = config.method || this.method;\n    this.config = config;\n    this.retry = {\n      ...this.retry,\n      ...(config.retry || {}),\n    };\n\n    this.requestInstance = this.isCustomFetcher()\n      ? (fetcher as any).create({\n          ...config,\n          baseURL: this.baseURL,\n          timeout: this.timeout,\n        })\n      : null;\n  }\n\n  /**\n   * Get Provider Instance\n   *\n   * @returns {FetcherInstance} Provider's instance\n   */\n  public getInstance(): FetcherInstance {\n    return this.requestInstance;\n  }\n\n  /**\n   * Replaces dynamic URI parameters in a URL string with values from the provided `urlPathParams` object.\n   * Parameters in the URL are denoted by `:<paramName>`, where `<paramName>` is a key in `urlPathParams`.\n   *\n   * @param {string} url - The URL string containing placeholders in the format `:<paramName>`.\n   * @param {Object} urlPathParams - An object containing the parameter values to replace placeholders.\n   * @param {string} urlPathParams.paramName - The value to replace the placeholder `:<paramName>` in the URL.\n   * @returns {string} - The URL string with placeholders replaced by corresponding values from `urlPathParams`.\n   */\n  public replaceUrlPathParams(\n    url: string,\n    urlPathParams: UrlPathParams,\n  ): string {\n    if (!urlPathParams) {\n      return url;\n    }\n\n    return url.replace(/:[a-zA-Z]+/gi, (str): string => {\n      const word = str.substring(1);\n\n      return String(urlPathParams[word] ? urlPathParams[word] : str);\n    });\n  }\n\n  /**\n   * Appends query parameters to the given URL\n   *\n   * @param {string} url - The base URL to which query parameters will be appended.\n   * @param {QueryParams} params - An instance of URLSearchParams containing the query parameters to append.\n   * @returns {string} - The URL with the appended query parameters.\n   */\n  public appendQueryParams(url: string, params: QueryParams): string {\n    if (!params) {\n      return url;\n    }\n\n    // We don't use URLSearchParams here as we want to ensure that arrays are properly converted similarily to Axios\n    // So { foo: [1, 2] } would become: foo[]=1&foo[]=2\n    const queryString = Object.entries(params)\n      .flatMap(([key, value]) => {\n        if (Array.isArray(value)) {\n          return value.map(\n            (val) => `${encodeURIComponent(key)}[]=${encodeURIComponent(val)}`,\n          );\n        }\n        return `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;\n      })\n      .join('&');\n\n    return url.includes('?')\n      ? `${url}&${queryString}`\n      : queryString\n        ? `${url}?${queryString}`\n        : url;\n  }\n\n  /**\n   * Checks if a value is JSON serializable.\n   *\n   * JSON serializable values include:\n   * - Primitive types: string, number, boolean, null\n   * - Arrays\n   * - Plain objects (i.e., objects without special methods)\n   * - Values with a `toJSON` method\n   *\n   * @param {any} value - The value to check for JSON serializability.\n   * @returns {boolean} - Returns `true` if the value is JSON serializable, otherwise `false`.\n   */\n  protected isJSONSerializable(value: any): boolean {\n    if (value === undefined || value === null) {\n      return false;\n    }\n\n    const t = typeof value;\n    if (t === 'string' || t === 'number' || t === 'boolean') {\n      return true;\n    }\n\n    if (t !== 'object') {\n      return false; // bigint, function, symbol, undefined\n    }\n\n    if (Array.isArray(value)) {\n      return true;\n    }\n\n    if (Buffer.isBuffer(value)) {\n      return false;\n    }\n\n    if (value instanceof Date) {\n      return false;\n    }\n\n    const proto = Object.getPrototypeOf(value);\n\n    // Check if the prototype is `Object.prototype` or `null` (plain object)\n    if (proto === Object.prototype || proto === null) {\n      return true;\n    }\n\n    // Check if the object has a toJSON method\n    if (typeof value.toJSON === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Build request configuration\n   *\n   * @param {string} url                          Request url\n   * @param {QueryParamsOrBody} data    Request data\n   * @param {RequestConfig} config               Request config\n   * @returns {RequestConfig}                    Provider's instance\n   */\n  protected buildConfig(\n    url: string,\n    data: QueryParamsOrBody,\n    config: RequestConfig,\n  ): RequestConfig {\n    const method = config.method || this.method;\n    const methodLowerCase = method.toLowerCase();\n    const isGetAlikeMethod =\n      methodLowerCase === 'get' || methodLowerCase === 'head';\n\n    const dynamicUrl = this.replaceUrlPathParams(\n      url,\n      config.urlPathParams || this.config.urlPathParams,\n    );\n\n    // Bonus: Specifying it here brings support for \"body\" in Axios\n    const configData =\n      config.body || config.data || this.config.body || this.config.data;\n\n    // Axios compatibility\n    if (this.isCustomFetcher()) {\n      return {\n        ...config,\n        url: dynamicUrl,\n        method: methodLowerCase,\n\n        ...(isGetAlikeMethod ? { params: data } : {}),\n\n        // For POST requests body payload is the first param for convenience (\"data\")\n        // In edge cases we want to split so to treat it as query params, and use \"body\" coming from the config instead\n        ...(!isGetAlikeMethod && data && configData ? { params: data } : {}),\n\n        // Only applicable for request methods 'PUT', 'POST', 'DELETE', and 'PATCH'\n        ...(!isGetAlikeMethod && data && !configData ? { data } : {}),\n        ...(!isGetAlikeMethod && configData ? { data: configData } : {}),\n      };\n    }\n\n    // Native fetch\n    const payload = configData || data;\n\n    delete config.data;\n\n    const urlPath =\n      (!isGetAlikeMethod && data && !config.body) || !data\n        ? dynamicUrl\n        : this.appendQueryParams(dynamicUrl, data);\n    const isFullUrl = urlPath.includes('://');\n    const baseURL = isFullUrl\n      ? ''\n      : typeof config.baseURL !== 'undefined'\n        ? config.baseURL\n        : this.baseURL;\n\n    return {\n      ...config,\n\n      // Native fetch generally requires query params to be appended in the URL\n      // Do not append query params only if it's a POST-alike request with only \"data\" specified as it's treated as body payload\n      url: baseURL + urlPath,\n\n      // Uppercase method name\n      method: method.toUpperCase(),\n\n      // For convenience, add the same default headers as Axios does\n      headers: {\n        Accept: 'application/json, text/plain, */*',\n        'Content-Type': 'application/json;charset=utf-8',\n        ...(config.headers || this.config.headers || {}),\n      } as RequestConfigHeaders,\n\n      // Automatically JSON stringify request bodies, if possible and when not dealing with strings\n      ...(!isGetAlikeMethod\n        ? {\n            body: this.isJSONSerializable(payload)\n              ? typeof payload === 'string'\n                ? payload\n                : JSON.stringify(payload)\n              : payload,\n          }\n        : {}),\n    };\n  }\n\n  /**\n   * Process global Request Error\n   *\n   * @param {RequestErrorResponse} error      Error instance\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {void}\n   */\n  protected processError(\n    error: RequestErrorResponse,\n    requestConfig: RequestConfig,\n  ): void {\n    if (this.isRequestCancelled(error)) {\n      return;\n    }\n\n    // Invoke per request \"onError\" call\n    if (requestConfig.onError && typeof requestConfig.onError === 'function') {\n      requestConfig.onError(error);\n    }\n\n    const errorHandler = new RequestErrorHandler(this.logger, this.onError);\n\n    errorHandler.process(error);\n  }\n\n  /**\n   * Output default response in case of an error, depending on chosen strategy\n   *\n   * @param {RequestErrorResponse} error      Error instance\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {*} Error response\n   */\n  protected async outputErrorResponse(\n    error: RequestErrorResponse,\n    requestConfig: RequestConfig,\n  ): Promise<any> {\n    const isRequestCancelled = this.isRequestCancelled(error);\n    const errorHandlingStrategy = requestConfig.strategy || this.strategy;\n    const rejectCancelled =\n      typeof requestConfig.rejectCancelled !== 'undefined'\n        ? requestConfig.rejectCancelled\n        : this.rejectCancelled;\n    const defaultResponse =\n      typeof requestConfig.defaultResponse !== 'undefined'\n        ? requestConfig.defaultResponse\n        : this.defaultResponse;\n\n    // By default cancelled requests aren't rejected\n    if (isRequestCancelled && !rejectCancelled) {\n      return defaultResponse;\n    }\n\n    if (errorHandlingStrategy === 'silent') {\n      // Hang the promise\n      await new Promise(() => null);\n\n      return defaultResponse;\n    }\n\n    // Simply rejects a request promise\n    if (errorHandlingStrategy === 'reject') {\n      return Promise.reject(error);\n    }\n\n    return defaultResponse;\n  }\n\n  /**\n   * Output error response depending on chosen strategy\n   *\n   * @param {RequestErrorResponse} error               Error instance\n   * @returns {boolean}                        True if request is aborted\n   */\n  public isRequestCancelled(error: RequestErrorResponse): boolean {\n    return error.name === 'AbortError' || error.name === 'CanceledError';\n  }\n\n  /**\n   * Detects if a custom fetcher is utilized\n   *\n   * @returns {boolean}                        True if it's a custom fetcher\n   */\n  protected isCustomFetcher(): boolean {\n    return this.fetcher !== null;\n  }\n\n  /**\n   * Automatically Cancel Previous Requests using AbortController when \"cancellable\" is defined\n   *\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {Object} Controller Signal to abort\n   */\n  protected addCancellationToken(\n    requestConfig: RequestConfig,\n  ): Partial<Record<'signal', AbortSignal>> {\n    // Both disabled\n    if (!this.cancellable && !requestConfig.cancellable) {\n      return {};\n    }\n\n    // Explicitly disabled per request\n    if (\n      typeof requestConfig.cancellable !== 'undefined' &&\n      !requestConfig.cancellable\n    ) {\n      return {};\n    }\n\n    // Check if AbortController is available\n    if (typeof AbortController === 'undefined') {\n      console.error('AbortController is unavailable.');\n\n      return {};\n    }\n\n    // Generate unique key as a cancellation token\n    const previousRequest = this.requestsQueue.get(requestConfig);\n\n    if (previousRequest) {\n      previousRequest.abort();\n    }\n\n    const controller = new AbortController();\n\n    // Introduce timeout for native fetch\n    if (!this.isCustomFetcher()) {\n      const abortTimeout = setTimeout(() => {\n        const error = new Error(\n          `[TimeoutError]: The ${requestConfig.url} request was aborted due to timeout`,\n        );\n\n        error.name = 'TimeoutError';\n        (error as any).code = 23; // DOMException.TIMEOUT_ERR\n        controller.abort(error);\n        clearTimeout(abortTimeout);\n        throw error;\n      }, requestConfig.timeout || this.timeout);\n    }\n\n    this.requestsQueue.set(requestConfig, controller);\n\n    return {\n      signal: controller.signal,\n    };\n  }\n\n  /**\n   * Handle Request depending on used strategy\n   *\n   * @param {string} url - Request url\n   * @param {QueryParamsOrBody} data - Request data\n   * @param {RequestConfig} config - Request config\n   * @param {RequestConfig} payload.config               Request config\n   * @throws {RequestErrorResponse}\n   * @returns {Promise<Response & FetchResponse<Response>>} Response Data\n   */\n  public async request<Response = APIResponse>(\n    url: string,\n    data: QueryParamsOrBody = null,\n    config: RequestConfig = null,\n  ): Promise<Response & FetchResponse<Response>> {\n    let response: Response | FetchResponse<Response> = null;\n    const _config = config || {};\n    const _requestConfig = this.buildConfig(url, data, _config);\n\n    let requestConfig: RequestConfig = {\n      ...this.addCancellationToken(_requestConfig),\n      ..._requestConfig,\n    };\n\n    const { retries, delay, backoff, retryOn, shouldRetry, maxDelay } = {\n      ...this.retry,\n      ...(requestConfig?.retry || {}),\n    };\n\n    let attempt = 0;\n    let waitTime = delay;\n\n    while (attempt <= retries) {\n      try {\n        // Local interceptors\n        requestConfig = await interceptRequest(\n          requestConfig,\n          requestConfig.onRequest,\n        );\n\n        // Global interceptors\n        requestConfig = await interceptRequest(\n          requestConfig,\n          this.config.onRequest,\n        );\n\n        // Axios compatibility\n        if (this.isCustomFetcher()) {\n          response = (await (this.requestInstance as any).request(\n            requestConfig,\n          )) as FetchResponse<Response>;\n        } else {\n          response = (await globalThis.fetch(\n            requestConfig.url,\n            requestConfig,\n          )) as ExtendedResponse;\n\n          // Add more information to response object\n          response.config = requestConfig;\n\n          // Check if the response status is not outside the range 200-299\n          if (response.ok) {\n            const contentType = String(\n              response?.headers?.get('Content-Type') || '',\n            );\n            let data = null;\n\n            // Handle edge case of no content type being provided... We assume json here.\n            if (!contentType) {\n              try {\n                data = await response.json();\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n              } catch (_error) {\n                //\n              }\n            }\n\n            if (!data) {\n              if (contentType && contentType.includes('application/json')) {\n                // Parse JSON response\n                data = await response.json();\n              } else if (typeof response.text !== 'undefined') {\n                data = await response.text();\n              } else if (typeof response.blob !== 'undefined') {\n                data = await response.blob();\n              } else {\n                // Handle streams\n                data = response.body || response.data || null;\n              }\n            }\n\n            response.data = data;\n          } else {\n            response.data = null;\n\n            // Output error in similar format to what Axios does\n            throw new RequestError(\n              `fetchf() Request Failed! Status: ${response.status || null}`,\n              requestConfig,\n              response,\n            );\n          }\n        }\n\n        // Local interceptors\n        response = await interceptResponse(response, requestConfig.onResponse);\n\n        // Global interceptors\n        response = await interceptResponse(response, this.config.onResponse);\n\n        return this.processResponseData(response, requestConfig);\n      } catch (error) {\n        if (\n          attempt === retries ||\n          !(await shouldRetry(error, attempt)) ||\n          !retryOn?.includes(\n            (response as FetchResponse<Response>)?.status ||\n              error?.response?.status ||\n              error?.status,\n          )\n        ) {\n          this.processError(error, requestConfig);\n\n          return this.outputErrorResponse(error, requestConfig);\n        }\n\n        if (this.logger?.warn) {\n          this.logger.warn(\n            `Attempt ${attempt + 1} failed. Retrying in ${waitTime}ms...`,\n          );\n        }\n\n        await this.delay(waitTime);\n\n        waitTime *= backoff;\n        waitTime = Math.min(waitTime, maxDelay);\n        attempt++;\n      }\n    }\n\n    return this.processResponseData(response, requestConfig);\n  }\n\n  public async delay(ms: number): Promise<boolean> {\n    return new Promise((resolve) =>\n      setTimeout(() => {\n        return resolve(true);\n      }, ms),\n    );\n  }\n\n  /**\n   * Process response\n   *\n   * @param response - Response payload\n   * @param {RequestConfig} requestConfig - Request config\n   * @returns {*} Response data\n   */\n  protected processResponseData(response, requestConfig: RequestConfig) {\n    const defaultResponse =\n      typeof requestConfig.defaultResponse !== 'undefined'\n        ? requestConfig.defaultResponse\n        : this.defaultResponse;\n\n    if (!response) {\n      return defaultResponse;\n    }\n\n    if (\n      (requestConfig.flattenResponse || this.flattenResponse) &&\n      typeof response.data !== 'undefined'\n    ) {\n      // Special case of only data property within response data object (happens in Axios)\n      // This is in fact a proper response but we may want to flatten it\n      // To ease developers' lives when obtaining the response\n      if (\n        typeof response.data === 'object' &&\n        typeof response.data.data !== 'undefined' &&\n        Object.keys(response.data).length === 1\n      ) {\n        return response.data.data;\n      }\n\n      return response.data;\n    }\n\n    // If empty object is returned, ensure that the default response is used instead\n    if (\n      typeof response === 'object' &&\n      response.constructor === Object &&\n      Object.keys(response).length === 0\n    ) {\n      return defaultResponse;\n    }\n\n    // For fetch()\n    const isCustomFetcher = this.isCustomFetcher();\n\n    if (!isCustomFetcher) {\n      return {\n        ...response,\n        headers: Array.from(response?.headers?.entries() || {}).reduce(\n          (acc, [key, value]) => {\n            acc[key] = value;\n            return acc;\n          },\n          {},\n        ),\n        config: requestConfig,\n      };\n    }\n\n    return response;\n  }\n}\n","import { RequestHandler } from './request-handler';\nimport type {\n  FetcherInstance,\n  RequestConfig,\n  FetchResponse,\n} from './types/request-handler';\nimport type {\n  ApiHandlerConfig,\n  ApiHandlerMethods,\n  ApiHandlerReturnType,\n  APIResponse,\n  QueryParams,\n  UrlPathParams,\n} from './types/api-handler';\n\n/**\n * Creates an instance of API Handler.\n * It creates an API fetcher function using native fetch() or Axios if it is passed as \"fetcher\".\n *\n * @param {Object} config - Configuration object for the API fetcher.\n * @param {string} config.apiUrl - The base URL for the API.\n * @param {Object} config.endpoints - An object containing endpoint definitions.\n * @param {number} config.timeout - You can set the timeout for particular request in milliseconds.\n * @param {number} config.cancellable - If true, the previous requests will be automatically cancelled.\n * @param {number} config.rejectCancelled - If true and request is set to cancellable, a cancelled request promise will be rejected. By default, instead of rejecting the promise, defaultResponse is returned.\n * @param {number} config.timeout - Request timeout\n * @param {string} config.strategy - Error Handling Strategy\n * @param {string} config.flattenResponse - Whether to flatten response \"data\" object within \"data\" one\n * @param {*} config.defaultResponse - Default response when there is no data or when endpoint fails depending on the chosen strategy. It's \"null\" by default\n * @param {Object} [config.retry] - Options for retrying requests.\n * @param {number} [config.retry.retries=0] - Number of retry attempts. No retries by default.\n * @param {number} [config.retry.delay=1000] - Initial delay between retries in milliseconds.\n * @param {number} [config.retry.backoff=1.5] - Exponential backoff factor.\n * @param {number[]} [config.retry.retryOn=[502, 504, 408]] - HTTP status codes to retry on.\n * @param {RequestInterceptor|RequestInterceptor[]} [config.onRequest] - Optional request interceptor function or an array of functions.\n * These functions will be called with the request configuration object before the request is made. Can be used to modify or log the request configuration.\n * @param {ResponseInterceptor|ResponseInterceptor[]} [config.onResponse] - Optional response interceptor function or an array of functions.\n * These functions will be called with the response object after the response is received. an be used to modify or log the response data.\n * @param {Function} [config.onError] - Optional callback function for handling errors.\n * @param {Object} [config.headers] - Optional default headers to include in every request.\n * @param {Object} config.fetcher - The Axios (or any other) instance to use for making requests.\n * @param {*} config.logger - Instance of custom logger. Either class or an object similar to \"console\". Console is used by default.\n * @returns API handler functions and endpoints to call\n *\n * @example\n * // Import axios (optional)\n * import axios from 'axios';\n *\n * // Define endpoint paths\n * const endpoints = {\n *   getUser: '/user',\n *   createPost: '/post',\n * };\n *\n * // Create the API fetcher with configuration\n * const api = createApiFetcher({\n *   fetcher: axios, // Axios instance (optional)\n *   endpoints,\n *   apiUrl: 'https://example.com/api',\n *   onError(error) {\n *     console.log('Request failed', error);\n *   },\n *   headers: {\n *     'my-auth-key': 'example-auth-key-32rjjfa',\n *   },\n * });\n *\n * // Fetch user data\n * const response = await api.getUser({ userId: 1, ratings: [1, 2] })\n */\nfunction createApiFetcher<EndpointsMethods = never, EndpointsCfg = never>(\n  config: ApiHandlerConfig<EndpointsMethods>,\n) {\n  const endpoints = config.endpoints;\n  const requestHandler = new RequestHandler(config);\n\n  /**\n   * Get Fetcher Provider Instance\n   *\n   * @returns {FetcherInstance} Request Handler's Fetcher instance\n   */\n  function getInstance(): FetcherInstance {\n    return requestHandler.getInstance();\n  }\n\n  /**\n   * Triggered when trying to use non-existent endpoints\n   *\n   * @param endpointName Endpoint Name\n   * @returns {Promise}\n   */\n  function handleNonImplemented(endpointName: string): Promise<null> {\n    console.error(`${endpointName} endpoint must be added to 'endpoints'.`);\n\n    return Promise.resolve(null);\n  }\n\n  /**\n   * Handle Single API Request\n   * It considers settings in following order: per-request settings, global per-endpoint settings, global settings.\n   *\n   * @param {string} endpointName - The name of the API endpoint to call.\n   * @param {QueryParams} [queryParams={}] - Query parameters to include in the request.\n   * @param {UrlPathParams} [urlPathParams={}] - URI parameters to include in the request.\n   * @param {EndpointConfig} [requestConfig={}] - Additional configuration for the request.\n   * @returns {Promise<Response & FetchResponse>} - A promise that resolves with the response from the API provider.\n   */\n  async function request<Response = APIResponse>(\n    endpointName: keyof EndpointsMethods | string,\n    queryParams: QueryParams = {},\n    urlPathParams: UrlPathParams = {},\n    requestConfig: RequestConfig = {},\n  ): Promise<Response & FetchResponse<Response>> {\n    // Use global per-endpoint settings\n    const endpointConfig = endpoints[endpointName as string];\n    const endpointSettings = { ...endpointConfig };\n\n    const responseData = await requestHandler.request<Response>(\n      endpointSettings.url,\n      queryParams,\n      {\n        ...endpointSettings,\n        ...requestConfig,\n        urlPathParams,\n      },\n    );\n\n    return responseData;\n  }\n\n  /**\n   * Maps all API requests using native Proxy\n   *\n   * @param {*} prop          Caller\n   */\n  function get(prop: string | symbol) {\n    if (prop in apiHandler) {\n      return apiHandler[prop];\n    }\n\n    // Prevent handler from triggering non-existent endpoints\n    if (!endpoints[prop as string]) {\n      return handleNonImplemented.bind(null, prop);\n    }\n\n    return apiHandler.request.bind(null, prop);\n  }\n\n  const apiHandler: ApiHandlerMethods<EndpointsMethods> = {\n    config,\n    endpoints,\n    requestHandler,\n    getInstance,\n    request,\n  };\n\n  return new Proxy(apiHandler, {\n    get: (_target, prop) => get(prop),\n  }) as ApiHandlerReturnType<EndpointsMethods, EndpointsCfg>;\n}\n\nexport { createApiFetcher };\n"],"mappings":"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","names":["src_exports","__export","createApiFetcher","fetchf","__toCommonJS","RequestErrorHandler","logger","requestErrorService","error","_a","errorContext","RequestError","_RequestError","message","requestInfo","response","interceptRequest","config","interceptors","interceptorList","interceptedConfig","interceptor","interceptResponse","response","interceptedResponse","RequestHandler","fetcher","timeout","rejectCancelled","strategy","flattenResponse","defaultResponse","logger","onError","config","url","urlPathParams","str","word","params","queryString","key","value","val","proto","data","method","methodLowerCase","isGetAlikeMethod","dynamicUrl","configData","payload","urlPath","baseURL","error","requestConfig","RequestErrorHandler","isRequestCancelled","errorHandlingStrategy","previousRequest","controller","abortTimeout","_a","_b","_c","response","_config","_requestConfig","retries","delay","backoff","retryOn","shouldRetry","maxDelay","attempt","waitTime","interceptRequest","contentType","RequestError","interceptResponse","ms","resolve","acc","createApiFetcher","config","endpoints","requestHandler","RequestHandler","getInstance","handleNonImplemented","endpointName","request","queryParams","urlPathParams","requestConfig","endpointSettings","get","prop","apiHandler","_target","fetchf","url","config","RequestHandler"]}