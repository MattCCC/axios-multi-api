{"version":3,"sources":["../../src/index.ts","../../src/interceptor-manager.ts","../../src/response-error.ts","../../src/utils.ts","../../src/queue-manager.ts","../../src/const.ts","../../src/response-parser.ts","../../src/request-handler.ts","../../src/api-handler.ts"],"sourcesContent":["import { createRequestHandler } from './request-handler';\nimport type { APIResponse, FetchResponse, RequestHandlerConfig } from './types';\n\n/**\n * Simple wrapper for request fetching.\n * It abstracts the creation of RequestHandler, making it easy to perform API requests.\n *\n * @param {string | URL | globalThis.Request} url - Request URL.\n * @param {RequestHandlerConfig} config - Configuration object for the request handler.\n * @returns {Promise<ResponseData & FetchResponse<ResponseData>>} Response Data.\n */\nexport async function fetchf<ResponseData = APIResponse>(\n  url: string,\n  config: RequestHandlerConfig = {},\n): Promise<ResponseData & FetchResponse<ResponseData>> {\n  return createRequestHandler(config).request<ResponseData>(url, null, config);\n}\n\nexport * from './types';\nexport * from './api-handler';\n","import type { RequestHandlerConfig, FetchResponse } from './types';\nimport type {\n  RequestInterceptor,\n  ResponseInterceptor,\n} from './types/interceptor-manager';\n\n/**\n * Applies a series of request interceptors to the provided configuration.\n * @param {RequestHandlerConfig} config - The initial request configuration.\n * @param {RequestInterceptor | RequestInterceptor[]} interceptors - The request interceptor function(s) to apply.\n * @returns {Promise<RequestHandlerConfig>} - The modified request configuration.\n */\nexport async function interceptRequest(\n  config: RequestHandlerConfig,\n  interceptors?: RequestInterceptor | RequestInterceptor[],\n): Promise<RequestHandlerConfig> {\n  if (!interceptors) {\n    return config;\n  }\n\n  const interceptorList = Array.isArray(interceptors)\n    ? interceptors\n    : [interceptors];\n\n  let interceptedConfig = { ...config };\n\n  for (const interceptor of interceptorList) {\n    interceptedConfig = await interceptor(interceptedConfig);\n  }\n\n  return interceptedConfig;\n}\n\n/**\n * Applies a series of response interceptors to the provided response.\n * @param {FetchResponse<ResponseData>} response - The initial response object.\n * @param {ResponseInterceptor | ResponseInterceptor[]} interceptors - The response interceptor function(s) to apply.\n * @returns {Promise<FetchResponse<ResponseData>>} - The modified response object.\n */\nexport async function interceptResponse<ResponseData = unknown>(\n  response: FetchResponse<ResponseData>,\n  interceptors?: ResponseInterceptor | ResponseInterceptor[],\n): Promise<FetchResponse<ResponseData>> {\n  if (!interceptors) {\n    return response;\n  }\n\n  const interceptorList = Array.isArray(interceptors)\n    ? interceptors\n    : [interceptors];\n\n  let interceptedResponse = response;\n\n  for (const interceptor of interceptorList) {\n    interceptedResponse = await interceptor(interceptedResponse);\n  }\n\n  return interceptedResponse;\n}\n","import type { FetchResponse, RequestConfig } from './types';\n\nexport class ResponseErr extends Error {\n  response: FetchResponse;\n  request: RequestConfig;\n  config: RequestConfig;\n  status: number;\n  statusText: string;\n\n  constructor(\n    message: string,\n    requestInfo: RequestConfig,\n    response: FetchResponse,\n  ) {\n    super(message);\n\n    this.name = 'ResponseError';\n    this.message = message;\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.request = requestInfo;\n    this.config = requestInfo;\n    this.response = response;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { HeadersObject, QueryParams, UrlPathParams } from './types';\n\n/**\n * Appends query parameters to a given URL.\n *\n * @param {string} url - The base URL to which query parameters will be appended.\n * @param {QueryParams} params - An object containing the query parameters to append.\n * @returns {string} - The URL with the appended query parameters.\n */\nexport function appendQueryParams(url: string, params: QueryParams): string {\n  if (!params) {\n    return url;\n  }\n\n  // Check if `params` is an instance of URLSearchParams and bail early if it is\n  if (params instanceof URLSearchParams) {\n    const encodedQueryString = params.toString();\n\n    return url.includes('?')\n      ? `${url}&${encodedQueryString}`\n      : encodedQueryString\n        ? `${url}?${encodedQueryString}`\n        : url;\n  }\n\n  // This is exact copy of what JQ used to do. It works much better than URLSearchParams\n  const s: string[] = [];\n  const add = function (k: string, v: any) {\n    v = typeof v === 'function' ? v() : v;\n    v = v === null ? '' : v === undefined ? '' : v;\n    s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v);\n  };\n\n  const buildParams = (prefix: string, obj: any) => {\n    let i: number, len: number, key: string;\n\n    if (prefix) {\n      if (Array.isArray(obj)) {\n        for (i = 0, len = obj.length; i < len; i++) {\n          buildParams(\n            prefix +\n              '[' +\n              (typeof obj[i] === 'object' && obj[i] ? i : '') +\n              ']',\n            obj[i],\n          );\n        }\n      } else if (typeof obj === 'object' && obj !== null) {\n        for (key in obj) {\n          buildParams(prefix + '[' + key + ']', obj[key]);\n        }\n      } else {\n        add(prefix, obj);\n      }\n    } else if (Array.isArray(obj)) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        add(obj[i].name, obj[i].value);\n      }\n    } else {\n      for (key in obj) {\n        buildParams(key, obj[key]);\n      }\n    }\n    return s;\n  };\n\n  const queryStringParts = buildParams('', params).join('&');\n\n  // Encode special characters as per RFC 3986, https://datatracker.ietf.org/doc/html/rfc3986\n  const encodedQueryString = queryStringParts.replace(/%5B%5D/g, '[]'); // Keep '[]' for arrays\n\n  return url.includes('?')\n    ? `${url}&${encodedQueryString}`\n    : encodedQueryString\n      ? `${url}?${encodedQueryString}`\n      : url;\n}\n\n/**\n * Replaces dynamic URI parameters in a URL string with values from the provided `urlPathParams` object.\n * Parameters in the URL are denoted by `:<paramName>`, where `<paramName>` is a key in `urlPathParams`.\n *\n * @param {string} url - The URL string containing placeholders in the format `:<paramName>`.\n * @param {Object} urlPathParams - An object containing the parameter values to replace placeholders.\n * @param {string} urlPathParams.paramName - The value to replace the placeholder `:<paramName>` in the URL.\n * @returns {string} - The URL string with placeholders replaced by corresponding values from `urlPathParams`.\n */\nexport function replaceUrlPathParams(\n  url: string,\n  urlPathParams: UrlPathParams,\n): string {\n  if (!urlPathParams) {\n    return url;\n  }\n\n  return url.replace(/:[a-zA-Z]+/gi, (str): string => {\n    const word = str.substring(1);\n\n    return String(urlPathParams[word] ? urlPathParams[word] : str);\n  });\n}\n\n/**\n * Checks if a value is JSON serializable.\n *\n * JSON serializable values include:\n * - Primitive types: string, number, boolean, null\n * - Arrays\n * - Plain objects (i.e., objects without special methods)\n * - Values with a `toJSON` method\n *\n * @param {any} value - The value to check for JSON serializability.\n * @returns {boolean} - Returns `true` if the value is JSON serializable, otherwise `false`.\n */\nexport function isJSONSerializable(value: any): boolean {\n  if (value === undefined || value === null) {\n    return false;\n  }\n\n  const t = typeof value;\n  if (t === 'string' || t === 'number' || t === 'boolean') {\n    return true;\n  }\n\n  if (t !== 'object') {\n    return false; // bigint, function, symbol, undefined\n  }\n\n  if (Array.isArray(value)) {\n    return true;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return false;\n  }\n\n  if (value instanceof Date) {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value);\n\n  // Check if the prototype is `Object.prototype` or `null` (plain object)\n  if (proto === Object.prototype || proto === null) {\n    return true;\n  }\n\n  // Check if the object has a toJSON method\n  if (typeof value.toJSON === 'function') {\n    return true;\n  }\n\n  return false;\n}\n\nexport async function delayInvocation(ms: number): Promise<boolean> {\n  return new Promise((resolve) =>\n    setTimeout(() => {\n      return resolve(true);\n    }, ms),\n  );\n}\n\n/**\n * Recursively flattens the data object if it meets specific criteria.\n *\n * The method checks if the provided `data` is an object with exactly one property named `data`.\n * If so, it recursively flattens the `data` property. Otherwise, it returns the `data` as-is.\n *\n * @param {any} data - The data to be flattened. Can be of any type, including objects, arrays, or primitives.\n * @returns {any} - The flattened data if the criteria are met; otherwise, the original `data`.\n */\nexport function flattenData(data: any): any {\n  if (\n    data &&\n    typeof data === 'object' &&\n    typeof data.data !== 'undefined' &&\n    Object.keys(data).length === 1\n  ) {\n    return flattenData(data.data);\n  }\n\n  return data;\n}\n\n/**\n * Processes headers and returns them as a normalized object.\n *\n * Handles both `Headers` instances and plain objects. Normalizes header keys to lowercase\n * as per RFC 2616 section 4.2.\n *\n * @param headers - The headers to process. Can be an instance of `Headers`, a plain object,\n *                   or `null`. If `null`, an empty object is returned.\n * @returns {HeadersObject} - A normalized headers object with lowercase keys.\n */\nexport function processHeaders(\n  headers?: (HeadersObject & HeadersInit) | null | Headers,\n): HeadersObject {\n  if (!headers) {\n    return {};\n  }\n\n  const headersObject: HeadersObject = {};\n\n  // Handle Headers object with entries() method\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      headersObject[key] = value;\n    });\n  } else if (typeof headers === 'object' && headers !== null) {\n    // Handle plain object\n    for (const [key, value] of Object.entries(headers)) {\n      // Normalize keys to lowercase as per RFC 2616 4.2\n      // https://datatracker.ietf.org/doc/html/rfc2616#section-4.2\n      headersObject[key.toLowerCase()] = value;\n    }\n  }\n\n  return headersObject;\n}\n\n/**\n * Deletes a property from an object if it exists.\n *\n * @param obj - The object from which to delete the property.\n * @param property - The property to delete from the object.\n */\nexport function deleteProperty<T extends Record<string, any>>(\n  obj: T | null,\n  property: keyof T,\n): void {\n  if (obj && property in obj) {\n    delete obj[property];\n  }\n}\n","import type { RequestConfig } from './types';\nimport type { QueueItem, RequestsQueue } from './types/queue-manager';\n\n/**\n * Queue Manager is responsible for managing and controlling the flow of concurrent or sequential requests. It handles:\n * - Request Queueing and Deduplication\n * - Request Timeout Handling\n * - Abort Controller Management and Request Cancellation\n * - Concurrency Control and Locking\n * - Request Lifecycle Management\n */\nconst queue: RequestsQueue = new Map<RequestConfig, QueueItem>();\n\n/**\n * Adds a request to the queue if it's not already being processed within the dedupeTime interval.\n *\n * @param {RequestConfig} config - The request configuration object.\n * @param {number} timeout - Timeout in milliseconds for the request.\n * @param {number} dedupeTime - Deduplication time in milliseconds.\n * @param {boolean} isCancellable - If true, then the previous request with same configuration should be aborted.\n * @param {boolean} isTimeoutEnabled - Whether timeout is enabled.\n * @returns {Promise<AbortController>} - A promise that resolves to an AbortController.\n */\nexport async function addRequest(\n  config: RequestConfig,\n  timeout: number,\n  dedupeTime: number = 0,\n  isCancellable: boolean = false,\n  isTimeoutEnabled: boolean = true,\n): Promise<AbortController> {\n  const now = Date.now();\n  const item = queue.get(config);\n\n  if (item) {\n    // If the request is already in the queue and within the dedupeTime, reuse the existing controller\n    if (!item.isCancellable && now - item.timestamp < dedupeTime) {\n      return item.controller;\n    }\n\n    // If the request is too old, remove it and proceed to add a new one\n    // Abort previous request, if applicable, and continue as usual\n    if (item.isCancellable) {\n      item.controller.abort(\n        new DOMException('Aborted due to new request', 'AbortError'),\n      );\n    }\n\n    if (item.timeoutId !== null) {\n      clearTimeout(item.timeoutId);\n    }\n\n    queue.delete(config);\n  }\n\n  const controller = new AbortController();\n\n  const timeoutId = isTimeoutEnabled\n    ? setTimeout(() => {\n        const error = new DOMException(\n          `${config.url} aborted due to timeout`,\n          'TimeoutError',\n        );\n\n        removeRequest(config, error);\n      }, timeout)\n    : null;\n\n  queue.set(config, { controller, timeoutId, timestamp: now, isCancellable });\n\n  return controller;\n}\n\n/**\n * Removes a request from the queue and clears its timeout.\n *\n * @param config - The request configuration.\n * @param {boolean} error - Error payload so to force the request to abort.\n */\nexport async function removeRequest(\n  config: RequestConfig,\n  error: DOMException | null | string = null,\n): Promise<void> {\n  const item = queue.get(config);\n\n  if (item) {\n    // If the request is not yet aborted, abort it with the provided error\n    if (error && !item.controller.signal.aborted) {\n      item.controller.abort(error);\n    }\n\n    if (item.timeoutId !== null) {\n      clearTimeout(item.timeoutId);\n    }\n\n    queue.delete(config);\n  }\n}\n\n/**\n * Gets the AbortController for a request configuration.\n *\n * @param config - The request configuration.\n * @returns {AbortController | undefined} - The AbortController or undefined.\n */\nexport async function getController(\n  config: RequestConfig,\n): Promise<AbortController | undefined> {\n  const item = queue.get(config);\n\n  return item?.controller;\n}\n","export const APPLICATION_JSON = 'application/json';\nexport const CONTENT_TYPE = 'Content-Type';\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { APPLICATION_JSON, CONTENT_TYPE } from './const';\nimport type { APIResponse } from './types/api-handler';\nimport type { FetchResponse } from './types/request-handler';\n\n/**\n * Parses the response data based on the Content-Type header.\n *\n * @param response - The Response object to parse.\n * @returns A Promise that resolves to the parsed data.\n */\nexport async function parseResponseData<ResponseData = APIResponse>(\n  response: FetchResponse<ResponseData>,\n): Promise<any> {\n  // Bail early when body is empty\n  if (!response?.body) {\n    return null;\n  }\n\n  const contentType = String(\n    (response as Response).headers?.get(CONTENT_TYPE) || '',\n  ).split(';')[0]; // Correctly handle charset\n\n  let data;\n\n  try {\n    if (\n      contentType.includes(APPLICATION_JSON) ||\n      contentType.includes('+json')\n    ) {\n      data = await response.json(); // Parse JSON response\n    } else if (contentType.includes('multipart/form-data')) {\n      data = await response.formData(); // Parse as FormData\n    } else if (contentType.includes('application/octet-stream')) {\n      data = await response.blob(); // Parse as blob\n    } else if (contentType.includes('application/x-www-form-urlencoded')) {\n      data = await response.formData(); // Handle URL-encoded forms\n    } else if (contentType.includes('text/')) {\n      data = await response.text(); // Parse as text\n    } else {\n      try {\n        const responseClone = response.clone();\n\n        // Handle edge case of no content type being provided... We assume JSON here.\n        data = await responseClone.json();\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (_e) {\n        // Handle streams\n        data = await response.text();\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  } catch (_error) {\n    // Parsing failed, fallback to null\n    data = null;\n  }\n\n  return data;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  RequestHandlerConfig,\n  RequestConfig,\n  FetcherInstance,\n  Method,\n  RetryOptions,\n  FetchResponse,\n  ResponseError,\n  RequestHandlerReturnType,\n} from './types/request-handler';\nimport type {\n  APIResponse,\n  BodyPayload,\n  QueryParams,\n  QueryParamsOrBody,\n} from './types/api-handler';\nimport { interceptRequest, interceptResponse } from './interceptor-manager';\nimport { ResponseErr } from './response-error';\nimport {\n  appendQueryParams,\n  isJSONSerializable,\n  replaceUrlPathParams,\n  delayInvocation,\n  flattenData,\n  processHeaders,\n  deleteProperty,\n} from './utils';\nimport { addRequest, removeRequest } from './queue-manager';\nimport { APPLICATION_JSON, CONTENT_TYPE } from './const';\nimport { parseResponseData } from './response-parser';\n\nconst defaultConfig: RequestHandlerConfig = {\n  method: 'GET',\n  strategy: 'reject',\n  timeout: 30000,\n  rejectCancelled: false,\n  dedupeTime: 1000,\n  withCredentials: false,\n  flattenResponse: false,\n  defaultResponse: null,\n  logger: null,\n  fetcher: null,\n  baseURL: '',\n  retry: {\n    retries: 0,\n    delay: 1000,\n    maxDelay: 30000,\n    resetTimeout: true,\n    backoff: 1.5,\n\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n    retryOn: [\n      408, // Request Timeout\n      409, // Conflict\n      425, // Too Early\n      429, // Too Many Requests\n      500, // Internal Server Error\n      502, // Bad Gateway\n      503, // Service Unavailable\n      504, // Gateway Timeout\n    ],\n\n    shouldRetry: async () => true,\n  },\n};\n\n/**\n * Create a Request Handler\n *\n * @param {RequestHandlerConfig} config - Configuration object for the request handler\n * @returns {Object} An object with methods for handling requests\n */\nfunction createRequestHandler(\n  config: RequestHandlerConfig,\n): RequestHandlerReturnType {\n  const handlerConfig: RequestHandlerConfig = {\n    ...defaultConfig,\n    baseURL: config.apiUrl || '',\n    ...config,\n  };\n\n  /**\n   * Detects if a custom fetcher is utilized\n   *\n   * @returns {boolean}                        True if it's a custom fetcher\n   */\n  const isCustomFetcher = (): boolean => {\n    return handlerConfig.fetcher !== null;\n  };\n\n  const requestInstance = isCustomFetcher()\n    ? (handlerConfig.fetcher as any).create({\n        ...config,\n        baseURL: handlerConfig.baseURL,\n        timeout: handlerConfig.timeout,\n      })\n    : null;\n\n  /**\n   * Get Provider Instance\n   *\n   * @returns {FetcherInstance} Provider's instance\n   */\n  const getInstance = (): FetcherInstance => {\n    return requestInstance;\n  };\n\n  /**\n   * Build request configuration\n   *\n   * @param {string} url - Request url\n   * @param {QueryParamsOrBody} data - Query Params in case of GET and HEAD requests, body payload otherwise\n   * @param {RequestConfig} reqConfig - Request config passed when making the request\n   * @returns {RequestConfig} - Provider's instance\n   */\n  const buildConfig = (\n    url: string,\n    data: QueryParamsOrBody,\n    reqConfig: RequestConfig,\n  ): RequestConfig => {\n    const method = (\n      reqConfig.method || (handlerConfig.method as string)\n    ).toUpperCase() as Method;\n    const isGetAlikeMethod = method === 'GET' || method === 'HEAD';\n\n    const dynamicUrl = replaceUrlPathParams(\n      url,\n      reqConfig.urlPathParams || handlerConfig.urlPathParams || null,\n    );\n\n    // The explicitly passed \"params\"\n    const explicitParams = reqConfig.params || handlerConfig.params;\n\n    // The explicitly passed \"body\" or \"data\"\n    const explicitBodyData =\n      reqConfig.body ||\n      reqConfig.data ||\n      handlerConfig.body ||\n      handlerConfig.data;\n\n    // For convenience, in POST requests the body payload is the \"data\"\n    // In edge cases we want to use Query Params in the POST requests\n    // and use explicitly passed \"body\" or \"data\" from request config\n    const shouldTreatDataAsParams =\n      data && (isGetAlikeMethod || explicitBodyData) ? true : false;\n\n    // Final body data\n    let body: RequestConfig['data'];\n\n    // Only applicable for request methods 'PUT', 'POST', 'DELETE', and 'PATCH'\n    if (!isGetAlikeMethod) {\n      body = explicitBodyData || (data as BodyPayload);\n    }\n\n    if (isCustomFetcher()) {\n      return {\n        ...reqConfig,\n        method,\n        url: dynamicUrl,\n        params: shouldTreatDataAsParams\n          ? (data as QueryParams)\n          : explicitParams,\n        data: body,\n      };\n    }\n\n    // Native fetch\n    const isWithCredentials =\n      typeof reqConfig.withCredentials !== 'undefined'\n        ? reqConfig.withCredentials\n        : handlerConfig.withCredentials;\n\n    const credentials = isWithCredentials\n      ? 'include'\n      : reqConfig.credentials || handlerConfig.credentials || undefined;\n\n    deleteProperty(reqConfig, 'data');\n    deleteProperty(reqConfig, 'withCredentials');\n\n    const urlPath =\n      explicitParams || shouldTreatDataAsParams\n        ? appendQueryParams(dynamicUrl, explicitParams || (data as QueryParams))\n        : dynamicUrl;\n    const isFullUrl = urlPath.includes('://');\n    const baseURL = isFullUrl ? '' : reqConfig.baseURL || handlerConfig.baseURL;\n\n    // Automatically stringify request body, if possible and when not dealing with strings\n    if (\n      body &&\n      typeof body !== 'string' &&\n      !(body instanceof URLSearchParams) &&\n      isJSONSerializable(body)\n    ) {\n      body = JSON.stringify(body);\n    }\n\n    return {\n      ...reqConfig,\n      credentials,\n      body,\n      method,\n\n      url: baseURL + urlPath,\n\n      // Add sensible defaults\n      headers: {\n        Accept: APPLICATION_JSON + ', text/plain, */*',\n        'Accept-Encoding': 'gzip, deflate, br',\n        [CONTENT_TYPE]: APPLICATION_JSON + ';charset=utf-8',\n        ...(handlerConfig.headers || {}),\n        ...(reqConfig.headers || {}),\n      },\n    };\n  };\n\n  /**\n   * Process global Request Error\n   *\n   * @param {ResponseError} error      Error instance\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {void}\n   */\n  const processError = (\n    error: ResponseError,\n    requestConfig: RequestConfig,\n  ): void => {\n    if (isRequestCancelled(error)) {\n      return;\n    }\n\n    if (handlerConfig.logger?.warn) {\n      handlerConfig.logger.warn('API ERROR', error);\n    }\n\n    // Invoke per request \"onError\" interceptor\n    if (requestConfig.onError) {\n      requestConfig.onError(error);\n    }\n\n    // Invoke global \"onError\" interceptor\n    if (handlerConfig.onError) {\n      handlerConfig.onError(error);\n    }\n  };\n\n  /**\n   * Output default response in case of an error, depending on chosen strategy\n   *\n   * @param {ResponseError} error      Error instance\n   * @param {FetchResponse} response      Response\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {*} Error response\n   */\n  const outputErrorResponse = async (\n    error: ResponseError,\n    response: FetchResponse | null,\n    requestConfig: RequestConfig,\n  ): Promise<any> => {\n    const _isRequestCancelled = isRequestCancelled(error);\n    const errorHandlingStrategy =\n      requestConfig.strategy || handlerConfig.strategy;\n    const rejectCancelled =\n      typeof requestConfig.rejectCancelled !== 'undefined'\n        ? requestConfig.rejectCancelled\n        : handlerConfig.rejectCancelled;\n\n    // By default cancelled requests aren't rejected (softFail strategy)\n    if (!(_isRequestCancelled && !rejectCancelled)) {\n      // Hang the promise\n      if (errorHandlingStrategy === 'silent') {\n        await new Promise(() => null);\n      }\n      // Reject the promise\n      else if (errorHandlingStrategy === 'reject') {\n        return Promise.reject(error);\n      }\n    }\n\n    return outputResponse(response, requestConfig, error);\n  };\n\n  /**\n   * Output error response depending on chosen strategy\n   *\n   * @param {ResponseError} error               Error instance\n   * @returns {boolean}                        True if request is aborted\n   */\n  const isRequestCancelled = (error: ResponseError): boolean => {\n    return error.name === 'AbortError' || error.name === 'CanceledError';\n  };\n\n  /**\n   * Handle Request depending on used strategy\n   *\n   * @param {string} url - Request url\n   * @param {QueryParamsOrBody} data - Query Params in case of GET and HEAD requests, body payload otherwise\n   * @param {RequestConfig} reqConfig - Request config\n   * @throws {ResponseError}\n   * @returns {Promise<ResponseData & FetchResponse<ResponseData>>} Response Data\n   */\n  const request = async <ResponseData = APIResponse>(\n    url: string,\n    data: QueryParamsOrBody = null,\n    reqConfig: RequestConfig | null = null,\n  ): Promise<ResponseData & FetchResponse<ResponseData>> => {\n    let response: FetchResponse<ResponseData> | null = null;\n    const _reqConfig = reqConfig || {};\n    const fetcherConfig = buildConfig(url, data, _reqConfig);\n\n    const timeout =\n      typeof fetcherConfig.timeout !== 'undefined'\n        ? fetcherConfig.timeout\n        : (handlerConfig.timeout as number);\n    const isCancellable =\n      typeof fetcherConfig.cancellable !== 'undefined'\n        ? fetcherConfig.cancellable\n        : handlerConfig.cancellable;\n    const dedupeTime =\n      typeof fetcherConfig.dedupeTime !== 'undefined'\n        ? fetcherConfig.dedupeTime\n        : handlerConfig.dedupeTime;\n\n    const {\n      retries,\n      delay,\n      backoff,\n      retryOn,\n      shouldRetry,\n      maxDelay,\n      resetTimeout,\n    } = {\n      ...handlerConfig.retry,\n      ...(fetcherConfig?.retry || {}),\n    } as Required<RetryOptions>;\n\n    let attempt = 0;\n    let waitTime: number = delay;\n\n    while (attempt <= retries) {\n      try {\n        // Add the request to the queue. Make sure to handle deduplication, cancellation, timeouts in accordance to retry settings\n        const controller = await addRequest(\n          fetcherConfig,\n          timeout,\n          dedupeTime,\n          isCancellable,\n          // Reset timeouts by default or when retries are ON\n          timeout > 0 && (!retries || resetTimeout),\n        );\n        const signal = controller.signal;\n\n        let requestConfig: RequestConfig = {\n          signal,\n          ...fetcherConfig,\n        };\n\n        // Local interceptors\n        requestConfig = await interceptRequest(\n          requestConfig,\n          requestConfig?.onRequest,\n        );\n\n        // Global interceptors\n        requestConfig = await interceptRequest(\n          requestConfig,\n          handlerConfig?.onRequest,\n        );\n\n        if (isCustomFetcher()) {\n          response = (await (requestInstance as any).request(\n            requestConfig,\n          )) as FetchResponse<ResponseData>;\n        } else {\n          response = (await fetch(\n            requestConfig.url as string,\n            requestConfig as RequestInit,\n          )) as FetchResponse<ResponseData>;\n\n          // Add more information to response object\n          response.config = requestConfig;\n          response.data = await parseResponseData(response);\n\n          // Check if the response status is not outside the range 200-299 and if so, output error\n          if (!response.ok) {\n            throw new ResponseErr(\n              `${requestConfig.url} failed! Status: ${response.status || null}`,\n              requestConfig,\n              response,\n            );\n          }\n        }\n\n        // Local interceptors\n        response = await interceptResponse(response, requestConfig?.onResponse);\n\n        // Global interceptors\n        response = await interceptResponse(response, handlerConfig?.onResponse);\n\n        removeRequest(fetcherConfig);\n\n        return outputResponse(response, requestConfig) as ResponseData &\n          FetchResponse<ResponseData>;\n      } catch (err) {\n        const error = err as ResponseError;\n        const status = error?.response?.status || (error as any)?.status || 0;\n\n        if (\n          attempt === retries ||\n          !(await shouldRetry(error, attempt)) ||\n          !retryOn?.includes(status)\n        ) {\n          processError(error, fetcherConfig);\n\n          removeRequest(fetcherConfig);\n\n          return outputErrorResponse(error, response, fetcherConfig);\n        }\n\n        if (handlerConfig.logger?.warn) {\n          handlerConfig.logger.warn(\n            `Attempt ${attempt + 1} failed. Retrying in ${waitTime}ms...`,\n          );\n        }\n\n        await delayInvocation(waitTime);\n\n        waitTime *= backoff;\n        waitTime = Math.min(waitTime, maxDelay);\n        attempt++;\n      }\n    }\n\n    return outputResponse(response, fetcherConfig) as ResponseData &\n      FetchResponse<ResponseData>;\n  };\n\n  /**\n   * Output response\n   *\n   * @param response - Response payload\n   * @param {RequestConfig} requestConfig - Request config\n   * @param error - whether the response is erroneous\n   * @returns {ResponseData | FetchResponse<ResponseData>} Response data\n   */\n  const outputResponse = <ResponseData = APIResponse>(\n    response: FetchResponse<ResponseData> | null,\n    requestConfig: RequestConfig,\n    error: ResponseError<ResponseData> | null = null,\n  ): ResponseData | FetchResponse<ResponseData> => {\n    const defaultResponse =\n      typeof requestConfig.defaultResponse !== 'undefined'\n        ? requestConfig.defaultResponse\n        : handlerConfig.defaultResponse;\n    const flattenResponse =\n      typeof requestConfig.flattenResponse !== 'undefined'\n        ? requestConfig.flattenResponse\n        : handlerConfig.flattenResponse;\n\n    if (!response) {\n      return flattenResponse\n        ? defaultResponse\n        : {\n            error,\n            headers: null,\n            data: defaultResponse,\n            config: requestConfig,\n          };\n    }\n\n    // Clean up the error object\n    deleteProperty(error, 'response');\n    deleteProperty(error, 'request');\n    deleteProperty(error, 'config');\n\n    let data = response?.data;\n\n    // Set the default response if the provided data is an empty object\n    if (\n      data === undefined ||\n      data === null ||\n      (typeof data === 'object' && Object.keys(data).length === 0)\n    ) {\n      data = defaultResponse;\n    }\n\n    // Return flattened response immediately\n    if (flattenResponse) {\n      return flattenData(data);\n    }\n\n    if (isCustomFetcher()) {\n      return response;\n    }\n\n    return {\n      // Native fetch()\n      body: response.body,\n      blob: response.blob,\n      json: response.json,\n      text: response.text,\n      clone: response.clone,\n      bodyUsed: response.bodyUsed,\n      arrayBuffer: response.arrayBuffer,\n      formData: response.formData,\n      ok: response.ok,\n      redirected: response.redirected,\n      type: response.type,\n      url: response.url,\n      status: response.status,\n      statusText: response.statusText,\n\n      // Extend with extra information\n      error,\n      data,\n      headers: processHeaders(response.headers),\n      config: requestConfig,\n    };\n  };\n\n  return {\n    getInstance,\n    buildConfig,\n    config,\n    request,\n  };\n}\n\nexport { createRequestHandler };\n","import type {\n  FetcherInstance,\n  RequestConfig,\n  FetchResponse,\n} from './types/request-handler';\nimport type {\n  ApiHandlerConfig,\n  ApiHandlerMethods,\n  ApiHandlerReturnType,\n  APIResponse,\n  QueryParamsOrBody,\n  UrlPathParams,\n} from './types/api-handler';\nimport { createRequestHandler } from './request-handler';\n\n/**\n * Creates an instance of API Handler.\n * It creates an API fetcher function using native fetch() or a custom fetcher if it is passed as \"fetcher\".\n *\n * @param {Object} config - Configuration object for the API fetcher.\n * @param {string} config.apiUrl - The base URL for the API.\n * @param {Object} config.endpoints - An object containing endpoint definitions.\n * @param {number} config.timeout - You can set the timeout for particular request in milliseconds.\n * @param {number} config.cancellable - If true, the ongoing previous requests will be automatically cancelled.\n * @param {number} config.rejectCancelled - If true and request is set to cancellable, a cancelled request promise will be rejected. By default, instead of rejecting the promise, defaultResponse is returned.\n * @param {number} config.timeout - Request timeout\n * @param {string} config.strategy - Error Handling Strategy\n * @param {string} config.flattenResponse - Whether to flatten response \"data\" object within \"data\" one\n * @param {*} config.defaultResponse - Default response when there is no data or when endpoint fails depending on the chosen strategy. It's \"null\" by default\n * @param {Object} [config.retry] - Options for retrying requests.\n * @param {number} [config.retry.retries=0] - Number of retry attempts. No retries by default.\n * @param {number} [config.retry.delay=1000] - Initial delay between retries in milliseconds.\n * @param {number} [config.retry.backoff=1.5] - Exponential backoff factor.\n * @param {number[]} [config.retry.retryOn=[502, 504, 408]] - HTTP status codes to retry on.\n * @param {RequestInterceptor|RequestInterceptor[]} [config.onRequest] - Optional request interceptor function or an array of functions.\n * These functions will be called with the request configuration object before the request is made. Can be used to modify or log the request configuration.\n * @param {ResponseInterceptor|ResponseInterceptor[]} [config.onResponse] - Optional response interceptor function or an array of functions.\n * These functions will be called with the response object after the response is received. an be used to modify or log the response data.\n * @param {Function} [config.onError] - Optional callback function for handling errors.\n * @param {Object} [config.headers] - Optional default headers to include in every request.\n * @param {Object} config.fetcher - The Custom Fetcher instance to use for making requests. It should expose create() and request() functions.\n * @param {*} config.logger - Instance of custom logger. Either class or an object similar to \"console\". Console is used by default.\n * @returns API handler functions and endpoints to call\n *\n * @example\n * // Define endpoint paths\n * const endpoints = {\n *   getUser: '/user',\n *   createPost: '/post',\n * };\n *\n * // Create the API fetcher with configuration\n * const api = createApiFetcher({\n *   endpoints,\n *   apiUrl: 'https://example.com/api',\n *   onError(error) {\n *     console.log('Request failed', error);\n *   },\n *   headers: {\n *     'my-auth-key': 'example-auth-key-32rjjfa',\n *   },\n * });\n *\n * // Fetch user data\n * const response = await api.getUser({ userId: 1, ratings: [1, 2] })\n */\nfunction createApiFetcher<\n  EndpointsMethods extends object,\n  EndpointsCfg = never,\n>(config: ApiHandlerConfig<EndpointsMethods>) {\n  const endpoints = config.endpoints;\n  const requestHandler = createRequestHandler(config);\n\n  /**\n   * Get Fetcher Provider Instance\n   *\n   * @returns {FetcherInstance} Request Handler's Fetcher instance\n   */\n  function getInstance(): FetcherInstance {\n    return requestHandler.getInstance();\n  }\n\n  /**\n   * Triggered when trying to use non-existent endpoints\n   *\n   * @param endpointName Endpoint Name\n   * @returns {Promise}\n   */\n  function handleNonImplemented(endpointName: string): Promise<null> {\n    console.error(`${endpointName} endpoint must be added to 'endpoints'.`);\n\n    return Promise.resolve(null);\n  }\n\n  /**\n   * Handle Single API Request\n   * It considers settings in following order: per-request settings, global per-endpoint settings, global settings.\n   *\n   * @param {string} endpointName - The name of the API endpoint to call.\n   * @param {QueryParamsOrBody} [data={}] - Query parameters to include in the request.\n   * @param {UrlPathParams} [urlPathParams={}] - URI parameters to include in the request.\n   * @param {EndpointConfig} [requestConfig={}] - Additional configuration for the request.\n   * @returns {Promise<Response & FetchResponse>} - A promise that resolves with the response from the API provider.\n   */\n  async function request<Response = APIResponse>(\n    endpointName: keyof EndpointsMethods | string,\n    data: QueryParamsOrBody = {},\n    urlPathParams: UrlPathParams = {},\n    requestConfig: RequestConfig = {},\n  ): Promise<Response & FetchResponse<Response>> {\n    // Use global per-endpoint settings\n    const endpointConfig = endpoints[endpointName as string];\n\n    const responseData = await requestHandler.request<Response>(\n      endpointConfig.url,\n      data,\n      {\n        ...(endpointConfig || {}),\n        ...requestConfig,\n        urlPathParams,\n      },\n    );\n\n    return responseData;\n  }\n\n  /**\n   * Maps all API requests using native Proxy\n   *\n   * @param {*} prop          Caller\n   */\n  function get(prop: string) {\n    if (prop in apiHandler) {\n      return apiHandler[\n        prop as unknown as keyof ApiHandlerMethods<EndpointsMethods>\n      ];\n    }\n\n    // Prevent handler from triggering non-existent endpoints\n    if (!endpoints[prop]) {\n      return handleNonImplemented.bind(null, prop);\n    }\n\n    return apiHandler.request.bind(null, prop);\n  }\n\n  const apiHandler: ApiHandlerMethods<EndpointsMethods> = {\n    config,\n    endpoints,\n    requestHandler,\n    getInstance,\n    request,\n  };\n\n  return new Proxy(apiHandler, {\n    get: (_target, prop: string) => get(prop),\n  }) as ApiHandlerReturnType<EndpointsMethods, EndpointsCfg>;\n}\n\nexport { createApiFetcher };\n"],"mappings":"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","names":["src_exports","__export","createApiFetcher","fetchf","__toCommonJS","interceptRequest","config","interceptors","interceptorList","interceptedConfig","__spreadValues","interceptor","interceptResponse","response","interceptedResponse","ResponseErr","message","requestInfo","response","__publicField","appendQueryParams","url","params","encodedQueryString","s","add","k","v","buildParams","prefix","obj","i","len","key","replaceUrlPathParams","urlPathParams","str","word","isJSONSerializable","value","t","proto","delayInvocation","ms","resolve","flattenData","data","processHeaders","headers","headersObject","deleteProperty","property","queue","addRequest","config","timeout","dedupeTime","isCancellable","isTimeoutEnabled","now","item","controller","timeoutId","error","removeRequest","APPLICATION_JSON","CONTENT_TYPE","parseResponseData","response","_a","contentType","CONTENT_TYPE","data","APPLICATION_JSON","_e","_error","defaultConfig","createRequestHandler","config","handlerConfig","__spreadValues","__spreadProps","isCustomFetcher","requestInstance","getInstance","buildConfig","url","data","reqConfig","method","isGetAlikeMethod","dynamicUrl","replaceUrlPathParams","explicitParams","explicitBodyData","shouldTreatDataAsParams","body","credentials","deleteProperty","urlPath","appendQueryParams","baseURL","isJSONSerializable","APPLICATION_JSON","CONTENT_TYPE","processError","error","requestConfig","_a","isRequestCancelled","outputErrorResponse","response","_isRequestCancelled","errorHandlingStrategy","rejectCancelled","outputResponse","request","_b","fetcherConfig","timeout","isCancellable","dedupeTime","retries","delay","backoff","retryOn","shouldRetry","maxDelay","resetTimeout","attempt","waitTime","signal","addRequest","interceptRequest","parseResponseData","ResponseErr","interceptResponse","removeRequest","err","status","delayInvocation","defaultResponse","flattenResponse","flattenData","processHeaders","createApiFetcher","config","endpoints","requestHandler","createRequestHandler","getInstance","handleNonImplemented","endpointName","request","data","urlPathParams","requestConfig","endpointConfig","__spreadProps","__spreadValues","get","prop","apiHandler","_target","fetchf","url","config","createRequestHandler"]}