{"version":3,"sources":["../src/index.ts","../src/request-error-handler.ts","../src/request-error.ts","../src/request-handler.ts","../src/api-handler.ts"],"sourcesContent":["import { RequestHandler } from './request-handler';\nimport type { RequestHandlerConfig, RequestResponse } from './types';\n\n/**\n * Simple wrapper for request fetching.\n * It abstracts the creation of RequestHandler, making it easy to perform API requests.\n *\n * @param {string | URL | globalThis.Request} url - Request URL.\n * @param {Object} config - Configuration object for the request handler.\n * @returns {Promise<RequestResponse>} Response Data.\n */\nexport async function fetchf(\n  url: string,\n  config: RequestHandlerConfig = {},\n): Promise<RequestResponse> {\n  return new RequestHandler(config).request(\n    url,\n    config.body || config.data || config.params,\n    config,\n  );\n}\n\nexport * from './types';\nexport * from './api-handler';\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport class RequestErrorHandler {\n  /**\n   * Logger Class\n   *\n   * @type {*}\n   * @memberof RequestErrorHandler\n   */\n  protected logger: any;\n\n  /**\n   * Error Service Class\n   *\n   * @type {*}\n   * @memberof RequestErrorHandler\n   */\n  public requestErrorService: any;\n\n  public constructor(logger: any, requestErrorService: any) {\n    this.logger = logger;\n    this.requestErrorService = requestErrorService;\n  }\n\n  /**\n   * Process and Error\n   *\n   * @param {*} error Error instance or message\n   * @throws          Request error context\n   * @returns {void}\n   */\n  public process(error: string | Error): void {\n    if (this.logger?.warn) {\n      this.logger.warn('API ERROR', error);\n    }\n\n    let errorContext = error;\n\n    if (typeof error === 'string') {\n      errorContext = new Error(error);\n    }\n\n    if (this.requestErrorService) {\n      if (typeof this.requestErrorService.process !== 'undefined') {\n        this.requestErrorService.process(errorContext);\n      } else if (typeof this.requestErrorService === 'function') {\n        this.requestErrorService(errorContext);\n      }\n    }\n  }\n}\n","import type { RequestConfig } from './types';\n\nexport class RequestError extends Error {\n  response: Response;\n  request: RequestConfig;\n\n  constructor(message: string, requestInfo: RequestConfig, response: Response) {\n    super(message);\n\n    this.name = 'RequestError';\n    this.message = message;\n    this.request = requestInfo;\n    this.response = response;\n\n    // Clean stack trace\n    Error.captureStackTrace(this, RequestError);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { RequestErrorHandler } from './request-error-handler';\nimport type {\n  RequestResponse,\n  ErrorHandlingStrategy,\n  RequestHandlerConfig,\n  RequestConfig,\n  RequestError as RequestErrorResponse,\n  FetcherInstance,\n  Method,\n  RequestConfigHeaders,\n  RetryOptions,\n  FetchResponse,\n  ExtendedResponse,\n} from './types/request-handler';\nimport type {\n  QueryParams,\n  QueryParamsOrBody,\n  UrlPathParams,\n} from './types/api-handler';\nimport { RequestError } from './request-error';\n\n/**\n * Generic Request Handler\n * It creates an Request Fetcher instance and handles requests within that instance\n * It handles errors depending on a chosen error handling strategy\n */\nexport class RequestHandler {\n  /**\n   * @var requestInstance Provider's instance\n   */\n  public requestInstance: FetcherInstance;\n\n  /**\n   * @var baseURL Base API url\n   */\n  public baseURL: string = '';\n\n  /**\n   * @var timeout Request timeout\n   */\n  public timeout: number = 30000;\n\n  /**\n   * @var cancellable Response cancellation\n   */\n  public cancellable: boolean = false;\n\n  /**\n   * @var rejectCancelled Whether to reject cancelled requests or not\n   */\n  public rejectCancelled: boolean = false;\n\n  /**\n   * @var strategy Request timeout\n   */\n  public strategy: ErrorHandlingStrategy = 'reject';\n\n  /**\n   * @var method Request method\n   */\n  public method: Method | string = 'get';\n\n  /**\n   * @var flattenResponse Response flattening\n   */\n  public flattenResponse: boolean = true;\n\n  /**\n   * @var defaultResponse Response flattening\n   */\n  public defaultResponse: any = null;\n\n  /**\n   * @var fetcher Request Fetcher instance\n   */\n  protected fetcher: FetcherInstance;\n\n  /**\n   * @var logger Logger\n   */\n  protected logger: any;\n\n  /**\n   * @var requestErrorService HTTP error service\n   */\n  protected requestErrorService: any;\n\n  /**\n   * @var requestsQueue    Queue of requests\n   */\n  protected requestsQueue: Map<string, AbortController>;\n\n  /**\n   * Request Handler Config\n   */\n  protected retry: RetryOptions = {\n    retries: 0,\n    delay: 1000,\n    maxDelay: 30000,\n    backoff: 1.5,\n\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n    retryOn: [\n      408, // Request Timeout\n      409, // Conflict\n      425, // Too Early\n      429, // Too Many Requests\n      500, // Internal Server Error\n      502, // Bad Gateway\n      503, // Service Unavailable\n      504, // Gateway Timeout\n    ],\n\n    shouldRetry: async () => true,\n  };\n\n  /**\n   * Request Handler Config\n   */\n  public config: RequestHandlerConfig;\n\n  /**\n   * Creates an instance of RequestHandler.\n   *\n   * @param {Object} config - Configuration object for the request.\n   * @param {string} config.baseURL - The base URL for the request.\n   * @param {Object} config.endpoints - An object containing endpoint definitions.\n   * @param {number} config.timeout - You can set the timeout for particular request in milliseconds.\n   * @param {number} config.cancellable - If true, the previous requests will be automatically cancelled.\n   * @param {number} config.rejectCancelled - If true and request is set to cancellable, a cancelled request promise will be rejected. By default, instead of rejecting the promise, defaultResponse is returned.\n   * @param {number} config.timeout - Request timeout\n   * @param {string} config.strategy - Error Handling Strategy\n   * @param {string} config.flattenResponse - Whether to flatten response \"data\" object within \"data\" one\n   * @param {*} config.defaultResponse - Default response when there is no data or when endpoint fails depending on the chosen strategy. It's \"null\" by default\n   * @param {Object} [config.retry] - Options for retrying requests.\n   * @param {number} [config.retry.retries=0] - Number of retry attempts. No retries by default.\n   * @param {number} [config.retry.delay=1000] - Initial delay between retries in milliseconds.\n   * @param {number} [config.retry.backoff=1.5] - Exponential backoff factor.\n   * @param {number[]} [config.retry.retryOn=[502, 504, 408]] - HTTP status codes to retry on.\n   * @param {Function} [config.onError] - Optional callback function for handling errors.\n   * @param {Object} [config.headers] - Optional default headers to include in every request.\n   * @param {Object} config.fetcher - The Axios (or any other) instance to use for making requests.\n   * @param {*} config.logger - Instance of custom logger. Either class or an object similar to \"console\". Console is used by default.\n   */\n  public constructor({\n    fetcher = null,\n    timeout = null,\n    cancellable = false,\n    rejectCancelled = false,\n    strategy = null,\n    flattenResponse = null,\n    defaultResponse = {},\n    logger = null,\n    onError = null,\n    ...config\n  }: RequestHandlerConfig) {\n    this.fetcher = fetcher;\n    this.timeout =\n      timeout !== null && timeout !== undefined ? timeout : this.timeout;\n    this.strategy =\n      strategy !== null && strategy !== undefined ? strategy : this.strategy;\n    this.cancellable = cancellable || this.cancellable;\n    this.rejectCancelled = rejectCancelled || this.rejectCancelled;\n    this.flattenResponse =\n      flattenResponse !== null && flattenResponse !== undefined\n        ? flattenResponse\n        : this.flattenResponse;\n    this.defaultResponse = defaultResponse;\n    this.logger = logger || (globalThis ? globalThis.console : null) || null;\n    this.requestErrorService = onError;\n    this.requestsQueue = new Map();\n    this.baseURL = config.baseURL || config.apiUrl || '';\n    this.method = config.method || this.method;\n    this.config = config;\n    this.retry = {\n      ...this.retry,\n      ...(config.retry || {}),\n    };\n\n    this.requestInstance = this.isCustomFetcher()\n      ? (fetcher as any).create({\n          ...config,\n          baseURL: this.baseURL,\n          timeout: this.timeout,\n        })\n      : null;\n  }\n\n  /**\n   * Get Provider Instance\n   *\n   * @returns {FetcherInstance} Provider's instance\n   */\n  public getInstance(): FetcherInstance {\n    return this.requestInstance;\n  }\n\n  /**\n   * Replaces dynamic URI parameters in a URL string with values from the provided `urlPathParams` object.\n   * Parameters in the URL are denoted by `:<paramName>`, where `<paramName>` is a key in `urlPathParams`.\n   *\n   * @param {string} url - The URL string containing placeholders in the format `:<paramName>`.\n   * @param {Object} urlPathParams - An object containing the parameter values to replace placeholders.\n   * @param {string} urlPathParams.paramName - The value to replace the placeholder `:<paramName>` in the URL.\n   * @returns {string} - The URL string with placeholders replaced by corresponding values from `urlPathParams`.\n   */\n  public replaceUrlPathParams(\n    url: string,\n    urlPathParams: UrlPathParams,\n  ): string {\n    return url.replace(/:[a-zA-Z]+/gi, (str): string => {\n      const word = str.substring(1);\n\n      return String(urlPathParams[word] ? urlPathParams[word] : str);\n    });\n  }\n\n  /**\n   * Appends query parameters to the given URL\n   *\n   * @param {string} url - The base URL to which query parameters will be appended.\n   * @param {QueryParams} params - An instance of URLSearchParams containing the query parameters to append.\n   * @returns {string} - The URL with the appended query parameters.\n   */\n  public appendQueryParams(url: string, params: QueryParams): string {\n    // We don't use URLSearchParams here as we want to ensure that arrays are properly converted similarily to Axios\n    // So { foo: [1, 2] } would become: foo[]=1&foo[]=2\n    const queryString = Object.entries(params)\n      .flatMap(([key, value]) => {\n        if (Array.isArray(value)) {\n          return value.map(\n            (val) => `${encodeURIComponent(key)}[]=${encodeURIComponent(val)}`,\n          );\n        }\n        return `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;\n      })\n      .join('&');\n\n    return url.includes('?')\n      ? `${url}&${queryString}`\n      : queryString\n        ? `${url}?${queryString}`\n        : url;\n  }\n\n  /**\n   * Checks if a value is JSON serializable.\n   *\n   * JSON serializable values include:\n   * - Primitive types: string, number, boolean, null\n   * - Arrays\n   * - Plain objects (i.e., objects without special methods)\n   * - Values with a `toJSON` method\n   *\n   * @param {any} value - The value to check for JSON serializability.\n   * @returns {boolean} - Returns `true` if the value is JSON serializable, otherwise `false`.\n   */\n  protected isJSONSerializable(value: any): boolean {\n    if (value === undefined || value === null) {\n      return false;\n    }\n\n    const t = typeof value;\n    if (t === 'string' || t === 'number' || t === 'boolean') {\n      return true;\n    }\n\n    if (t !== 'object') {\n      return false; // bigint, function, symbol, undefined\n    }\n\n    if (Array.isArray(value)) {\n      return true;\n    }\n\n    if (Buffer.isBuffer(value)) {\n      return false;\n    }\n\n    if (value instanceof Date) {\n      return false;\n    }\n\n    const proto = Object.getPrototypeOf(value);\n\n    // Check if the prototype is `Object.prototype` or `null` (plain object)\n    if (proto === Object.prototype || proto === null) {\n      return true;\n    }\n\n    // Check if the object has a toJSON method\n    if (typeof value.toJSON === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Build request configuration\n   *\n   * @param {string} url                          Request url\n   * @param {QueryParamsOrBody} data    Request data\n   * @param {RequestConfig} config               Request config\n   * @returns {RequestConfig}                    Provider's instance\n   */\n  protected buildConfig(\n    url: string,\n    data: QueryParamsOrBody,\n    config: RequestConfig,\n  ): RequestConfig {\n    const method = config.method || this.method;\n    const methodLowerCase = method.toLowerCase();\n    const isGetAlikeMethod =\n      methodLowerCase === 'get' || methodLowerCase === 'head';\n\n    const dynamicUrl = this.replaceUrlPathParams(\n      url,\n      config.urlPathParams || this.config.urlPathParams,\n    );\n\n    // Bonus: Specifying it here brings support for \"body\" in Axios\n    const configData =\n      config.body || config.data || this.config.body || this.config.data;\n\n    // Axios compatibility\n    if (this.isCustomFetcher()) {\n      return {\n        ...config,\n        url: dynamicUrl,\n        method: methodLowerCase,\n\n        ...(isGetAlikeMethod ? { params: data } : {}),\n\n        // For POST requests body payload is the first param for convenience (\"data\")\n        // In edge cases we want to split so to treat it as query params, and use \"body\" coming from the config instead\n        ...(!isGetAlikeMethod && data && configData ? { params: data } : {}),\n\n        // Only applicable for request methods 'PUT', 'POST', 'DELETE', and 'PATCH'\n        ...(!isGetAlikeMethod && data && !configData ? { data } : {}),\n        ...(!isGetAlikeMethod && configData ? { data: configData } : {}),\n      };\n    }\n\n    // Native fetch\n    const payload = configData || data;\n\n    delete config.data;\n\n    return {\n      ...config,\n\n      // Native fetch generally requires query params to be appended in the URL\n      // Do not append query params only if it's a POST-alike request with only \"data\" specified as it's treated as body payload\n      url:\n        this.baseURL +\n        ((!isGetAlikeMethod && data && !config.body) || !data\n          ? dynamicUrl\n          : this.appendQueryParams(dynamicUrl, data)),\n\n      // Uppercase method name\n      method: method.toUpperCase(),\n\n      // For convenience, add the same default headers as Axios does\n      headers: {\n        Accept: 'application/json, text/plain, */*',\n        'Content-Type': 'application/json;charset=utf-8',\n        ...(config.headers || this.config.headers || {}),\n      } as RequestConfigHeaders,\n\n      // Automatically JSON stringify request bodies, if possible and when not dealing with strings\n      ...(!isGetAlikeMethod\n        ? {\n            body: this.isJSONSerializable(payload)\n              ? typeof payload === 'string'\n                ? payload\n                : JSON.stringify(payload)\n              : payload,\n          }\n        : {}),\n    };\n  }\n\n  /**\n   * Process global Request Error\n   *\n   * @param {RequestErrorResponse} error      Error instance\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {void}\n   */\n  protected processError(\n    error: RequestErrorResponse,\n    requestConfig: RequestConfig,\n  ): void {\n    if (this.isRequestCancelled(error)) {\n      return;\n    }\n\n    // Invoke per request \"onError\" call\n    if (requestConfig.onError && typeof requestConfig.onError === 'function') {\n      requestConfig.onError(error);\n    }\n\n    const errorHandler = new RequestErrorHandler(\n      this.logger,\n      this.requestErrorService,\n    );\n\n    errorHandler.process(error);\n  }\n\n  /**\n   * Output default response in case of an error, depending on chosen strategy\n   *\n   * @param {RequestErrorResponse} error      Error instance\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {*} Error response\n   */\n  protected async outputErrorResponse(\n    error: RequestErrorResponse,\n    requestConfig: RequestConfig,\n  ): Promise<RequestResponse> {\n    const isRequestCancelled = this.isRequestCancelled(error);\n    const errorHandlingStrategy = requestConfig.strategy || this.strategy;\n    const rejectCancelled =\n      typeof requestConfig.rejectCancelled !== 'undefined'\n        ? requestConfig.rejectCancelled\n        : this.rejectCancelled;\n    const defaultResponse =\n      typeof requestConfig.defaultResponse !== 'undefined'\n        ? requestConfig.defaultResponse\n        : this.defaultResponse;\n\n    // By default cancelled requests aren't rejected\n    if (isRequestCancelled && !rejectCancelled) {\n      return defaultResponse;\n    }\n\n    if (errorHandlingStrategy === 'silent') {\n      // Hang the promise\n      await new Promise(() => null);\n\n      return defaultResponse;\n    }\n\n    // Simply rejects a request promise\n    if (errorHandlingStrategy === 'reject') {\n      return Promise.reject(error);\n    }\n\n    return defaultResponse;\n  }\n\n  /**\n   * Output error response depending on chosen strategy\n   *\n   * @param {RequestErrorResponse} error               Error instance\n   * @returns {boolean}                        True if request is aborted\n   */\n  public isRequestCancelled(error: RequestErrorResponse): boolean {\n    return error.name === 'AbortError' || error.name === 'CanceledError';\n  }\n\n  /**\n   * Detects if a custom fetcher is utilized\n   *\n   * @returns {boolean}                        True if it's a custom fetcher\n   */\n  protected isCustomFetcher(): boolean {\n    return this.fetcher !== null;\n  }\n\n  /**\n   * Automatically Cancel Previous Requests using AbortController when \"cancellable\" is defined\n   *\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {Object} Controller Signal to abort\n   */\n  protected addCancellationToken(\n    requestConfig: RequestConfig,\n  ): Partial<Record<'signal', AbortSignal>> {\n    // Both disabled\n    if (!this.cancellable && !requestConfig.cancellable) {\n      return {};\n    }\n\n    // Explicitly disabled per request\n    if (\n      typeof requestConfig.cancellable !== 'undefined' &&\n      !requestConfig.cancellable\n    ) {\n      return {};\n    }\n\n    // Check if AbortController is available\n    if (typeof AbortController === 'undefined') {\n      console.error('AbortController is unavailable.');\n\n      return {};\n    }\n\n    const { method, baseURL, url, params, data } = requestConfig;\n\n    // Generate unique key as a cancellation token. Make sure it fits Map\n    const key = JSON.stringify([method, baseURL, url, params, data]).substring(\n      0,\n      55 ** 5,\n    );\n    const previousRequest = this.requestsQueue.get(key);\n\n    if (previousRequest) {\n      previousRequest.abort();\n    }\n\n    const controller = new AbortController();\n\n    // Introduce timeout for native fetch\n    if (!this.isCustomFetcher()) {\n      const abortTimeout = setTimeout(() => {\n        const error = new Error(\n          `[TimeoutError]: The ${url} request was aborted due to timeout`,\n        );\n\n        error.name = 'TimeoutError';\n        (error as any).code = 23; // DOMException.TIMEOUT_ERR\n        controller.abort(error);\n        clearTimeout(abortTimeout);\n      }, requestConfig.timeout || this.timeout);\n    }\n    this.requestsQueue.set(key, controller);\n\n    return {\n      signal: controller.signal,\n    };\n  }\n\n  /**\n   * Handle Request depending on used strategy\n   *\n   * @param {object} payload                              Payload\n   * @param {string} payload.url                          Request url\n   * @param {QueryParamsOrBody} payload.data    Request data\n   * @param {RequestConfig} payload.config               Request config\n   * @throws {RequestErrorResponse}\n   * @returns {Promise<FetchResponse>} Response Data\n   */\n  public async request(\n    url: string,\n    data: QueryParamsOrBody = null,\n    config: RequestConfig = null,\n  ): Promise<FetchResponse> {\n    let response: FetchResponse = null;\n    const endpointConfig = config || {};\n    let requestConfig = this.buildConfig(url, data, endpointConfig);\n\n    requestConfig = {\n      ...this.addCancellationToken(requestConfig),\n      ...requestConfig,\n    };\n\n    const { retries, delay, backoff, retryOn, shouldRetry, maxDelay } = {\n      ...this.retry,\n      ...(requestConfig?.retry || {}),\n    };\n\n    let attempt = 0;\n    let waitTime = delay;\n\n    while (attempt <= retries) {\n      try {\n        // Axios compatibility\n        if (this.isCustomFetcher()) {\n          response = await (this.requestInstance as any).request(requestConfig);\n        } else {\n          response = (await globalThis.fetch(\n            requestConfig.url,\n            requestConfig,\n          )) as ExtendedResponse;\n\n          // Add more information to response object\n          response.config = requestConfig;\n          response.data = requestConfig;\n\n          // Check if the response status is not outside the range 200-299\n          if (response.ok) {\n            response.data = await response.json();\n          } else {\n            // Output error in similar format to what Axios does\n            throw new RequestError(\n              'fetchf() Request Failed! Status: ${response.status}',\n              requestConfig,\n              response,\n            );\n          }\n        }\n\n        return this.processResponseData(response, requestConfig);\n      } catch (error) {\n        if (\n          attempt === retries ||\n          !(await shouldRetry(error, attempt)) ||\n          !retryOn?.includes(\n            response?.status || error?.response?.status || error?.status,\n          )\n        ) {\n          this.processError(error, requestConfig);\n\n          return this.outputErrorResponse(error, requestConfig);\n        }\n\n        if (this.logger?.warn) {\n          this.logger.warn(\n            `Attempt ${attempt + 1} failed. Retrying in ${waitTime}ms...`,\n          );\n        }\n\n        await this.delay(waitTime);\n\n        waitTime *= backoff;\n        waitTime = Math.min(waitTime, maxDelay);\n        attempt++;\n      }\n    }\n\n    return this.processResponseData(response, requestConfig);\n  }\n\n  public async delay(ms: number): Promise<boolean> {\n    return new Promise((resolve) =>\n      setTimeout(() => {\n        return resolve(true);\n      }, ms),\n    );\n  }\n\n  /**\n   * Process response\n   *\n   * @param response - Response payload\n   * @param {RequestConfig} requestConfig - Request config\n   * @returns {*} Response data\n   */\n  protected processResponseData(response, requestConfig: RequestConfig) {\n    const defaultResponse =\n      typeof requestConfig.defaultResponse !== 'undefined'\n        ? requestConfig.defaultResponse\n        : this.defaultResponse;\n\n    if (!response) {\n      return defaultResponse;\n    }\n\n    if (\n      (requestConfig.flattenResponse || this.flattenResponse) &&\n      typeof response.data !== 'undefined'\n    ) {\n      // Special case of only data property within response data object (happens in Axios)\n      // This is in fact a proper response but we may want to flatten it\n      // To ease developers' lives when obtaining the response\n      if (\n        typeof response.data === 'object' &&\n        typeof response.data.data !== 'undefined' &&\n        Object.keys(response.data).length === 1\n      ) {\n        return response.data.data;\n      }\n\n      return response.data;\n    }\n\n    // If empty object is returned, ensure that the default response is used instead\n    if (\n      typeof response === 'object' &&\n      response.constructor === Object &&\n      Object.keys(response).length === 0\n    ) {\n      return defaultResponse;\n    }\n\n    return response;\n  }\n}\n","import { RequestHandler } from './request-handler';\nimport type {\n  FetcherInstance,\n  RequestConfig,\n  FetchResponse,\n} from './types/request-handler';\nimport type {\n  ApiHandlerConfig,\n  ApiHandlerMethods,\n  ApiHandlerReturnType,\n  QueryParams,\n  UrlPathParams,\n} from './types/api-handler';\n\n/**\n * Creates an instance of API Handler.\n * It creates an API fetcher function using native fetch() or Axios if it is passed as \"fetcher\".\n *\n * @param {Object} config - Configuration object for the API fetcher.\n * @param {string} config.apiUrl - The base URL for the API.\n * @param {Object} config.endpoints - An object containing endpoint definitions.\n * @param {number} config.timeout - You can set the timeout for particular request in milliseconds.\n * @param {number} config.cancellable - If true, the previous requests will be automatically cancelled.\n * @param {number} config.rejectCancelled - If true and request is set to cancellable, a cancelled request promise will be rejected. By default, instead of rejecting the promise, defaultResponse is returned.\n * @param {number} config.timeout - Request timeout\n * @param {string} config.strategy - Error Handling Strategy\n * @param {string} config.flattenResponse - Whether to flatten response \"data\" object within \"data\" one\n * @param {*} config.defaultResponse - Default response when there is no data or when endpoint fails depending on the chosen strategy. It's \"null\" by default\n * @param {Object} [config.retry] - Options for retrying requests.\n * @param {number} [config.retry.retries=0] - Number of retry attempts. No retries by default.\n * @param {number} [config.retry.delay=1000] - Initial delay between retries in milliseconds.\n * @param {number} [config.retry.backoff=1.5] - Exponential backoff factor.\n * @param {number[]} [config.retry.retryOn=[502, 504, 408]] - HTTP status codes to retry on.\n * @param {Function} [config.onError] - Optional callback function for handling errors.\n * @param {Object} [config.headers] - Optional default headers to include in every request.\n * @param {Object} config.fetcher - The Axios (or any other) instance to use for making requests.\n * @param {*} config.logger - Instance of custom logger. Either class or an object similar to \"console\". Console is used by default.\n * @returns API handler functions and endpoints to call\n *\n * @example\n * // Import axios (optional)\n * import axios from 'axios';\n *\n * // Define endpoint paths\n * const endpoints = {\n *   getUser: '/user',\n *   createPost: '/post',\n * };\n *\n * // Create the API fetcher with configuration\n * const api = createApiFetcher({\n *   fetcher: axios, // Axios instance (optional)\n *   endpoints,\n *   apiUrl: 'https://example.com/api',\n *   onError(error) {\n *     console.log('Request failed', error);\n *   },\n *   headers: {\n *     'my-auth-key': 'example-auth-key-32rjjfa',\n *   },\n * });\n *\n * // Fetch user data\n * const response = await api.getUser({ userId: 1, ratings: [1, 2] })\n */\nfunction createApiFetcher<EndpointsMethods = never, EndpointsCfg = never>(\n  config: ApiHandlerConfig<EndpointsMethods>,\n) {\n  const endpoints = config.endpoints;\n  const requestHandler = new RequestHandler(config);\n\n  /**\n   * Get Fetcher Provider Instance\n   *\n   * @returns {FetcherInstance} Request Handler's Fetcher instance\n   */\n  function getInstance(): FetcherInstance {\n    return requestHandler.getInstance();\n  }\n\n  /**\n   * Triggered when trying to use non-existent endpoints\n   *\n   * @param endpointName Endpoint Name\n   * @returns {Promise}\n   */\n  function handleNonImplemented(endpointName: string): Promise<null> {\n    console.error(`${endpointName} endpoint must be added to 'endpoints'.`);\n\n    return Promise.resolve(null);\n  }\n\n  /**\n   * Handle Single API Request\n   * It considers settings in following order: per-request settings, global per-endpoint settings, global settings.\n   *\n   * @param {string} endpointName - The name of the API endpoint to call.\n   * @param {QueryParams} [queryParams={}] - Query parameters to include in the request.\n   * @param {UrlPathParams} [urlPathParams={}] - URI parameters to include in the request.\n   * @param {EndpointConfig} [requestConfig={}] - Additional configuration for the request.\n   * @returns {Promise<FetchResponse>} - A promise that resolves with the response from the API provider.\n   */\n  async function request(\n    endpointName: keyof EndpointsMethods & string,\n    queryParams: QueryParams = {},\n    urlPathParams: UrlPathParams = {},\n    requestConfig: RequestConfig = {},\n  ): Promise<FetchResponse> {\n    // Use global per-endpoint settings\n    const endpointConfig = endpoints[endpointName as string];\n    const endpointSettings = { ...endpointConfig };\n\n    const responseData = await requestHandler.request(\n      endpointSettings.url,\n      queryParams,\n      {\n        ...endpointSettings,\n        ...requestConfig,\n        urlPathParams,\n      },\n    );\n\n    return responseData;\n  }\n\n  /**\n   * Maps all API requests using native Proxy\n   *\n   * @param {*} prop          Caller\n   */\n  function get(prop: string | symbol) {\n    if (prop in apiHandler) {\n      return apiHandler[prop];\n    }\n\n    // Prevent handler from triggering non-existent endpoints\n    if (!endpoints[prop as string]) {\n      return handleNonImplemented.bind(null, prop);\n    }\n\n    return apiHandler.request.bind(null, prop);\n  }\n\n  const apiHandler: ApiHandlerMethods<EndpointsMethods> = {\n    config,\n    endpoints,\n    requestHandler,\n    getInstance,\n    request,\n  };\n\n  return new Proxy(apiHandler, {\n    get: (_target, prop) => get(prop),\n  }) as ApiHandlerReturnType<EndpointsMethods, EndpointsCfg>;\n}\n\nexport { createApiFetcher };\n"],"mappings":"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","names":["src_exports","__export","createApiFetcher","fetchf","__toCommonJS","RequestErrorHandler","logger","requestErrorService","error","_a","errorContext","RequestError","_RequestError","message","requestInfo","response","RequestHandler","fetcher","timeout","cancellable","rejectCancelled","strategy","flattenResponse","defaultResponse","logger","onError","config","url","urlPathParams","str","word","params","queryString","key","value","val","proto","data","method","methodLowerCase","isGetAlikeMethod","dynamicUrl","configData","payload","error","requestConfig","RequestErrorHandler","isRequestCancelled","errorHandlingStrategy","baseURL","previousRequest","controller","abortTimeout","_a","_b","response","endpointConfig","retries","delay","backoff","retryOn","shouldRetry","maxDelay","attempt","waitTime","RequestError","ms","resolve","createApiFetcher","config","endpoints","requestHandler","RequestHandler","getInstance","handleNonImplemented","endpointName","request","queryParams","urlPathParams","requestConfig","endpointSettings","get","prop","apiHandler","_target","fetchf","url","config","RequestHandler"]}