{"version":3,"sources":["../src/index.ts","../src/interceptor-manager.ts","../src/response-error.ts","../src/request-handler.ts","../src/api-handler.ts"],"sourcesContent":["import { RequestHandler } from './request-handler';\nimport type { APIResponse, FetchResponse, RequestHandlerConfig } from './types';\n\n/**\n * Simple wrapper for request fetching.\n * It abstracts the creation of RequestHandler, making it easy to perform API requests.\n *\n * @param {string | URL | globalThis.Request} url - Request URL.\n * @param {RequestHandlerConfig} config - Configuration object for the request handler.\n * @returns {Promise<ResponseData & FetchResponse<ResponseData>>} Response Data.\n */\nexport async function fetchf<ResponseData = APIResponse>(\n  url: string,\n  config: RequestHandlerConfig = {},\n): Promise<ResponseData & FetchResponse<ResponseData>> {\n  return new RequestHandler(config).request<ResponseData>(\n    url,\n    config.body || config.data || config.params,\n    config,\n  );\n}\n\nexport * from './types';\nexport * from './api-handler';\n","import type { RequestHandlerConfig, FetchResponse } from './types';\nimport type {\n  RequestInterceptor,\n  ResponseInterceptor,\n} from './types/interceptor-manager';\n\n/**\n * Applies a series of request interceptors to the provided configuration.\n * @param {RequestHandlerConfig} config - The initial request configuration.\n * @param {RequestInterceptor | RequestInterceptor[]} interceptors - The request interceptor function(s) to apply.\n * @returns {Promise<RequestHandlerConfig>} - The modified request configuration.\n */\nexport async function interceptRequest(\n  config: RequestHandlerConfig,\n  interceptors: RequestInterceptor | RequestInterceptor[],\n): Promise<RequestHandlerConfig> {\n  if (!interceptors) {\n    return config;\n  }\n\n  const interceptorList = Array.isArray(interceptors)\n    ? interceptors\n    : [interceptors];\n\n  let interceptedConfig = { ...config };\n\n  for (const interceptor of interceptorList) {\n    interceptedConfig = await interceptor(interceptedConfig);\n  }\n\n  return interceptedConfig;\n}\n\n/**\n * Applies a series of response interceptors to the provided response.\n * @param {FetchResponse<ResponseData>} response - The initial response object.\n * @param {ResponseInterceptor | ResponseInterceptor[]} interceptors - The response interceptor function(s) to apply.\n * @returns {Promise<FetchResponse<ResponseData>>} - The modified response object.\n */\nexport async function interceptResponse<ResponseData = unknown>(\n  response: FetchResponse<ResponseData>,\n  interceptors: ResponseInterceptor | ResponseInterceptor[],\n): Promise<FetchResponse<ResponseData>> {\n  if (!interceptors) {\n    return response;\n  }\n\n  const interceptorList = Array.isArray(interceptors)\n    ? interceptors\n    : [interceptors];\n\n  let interceptedResponse = response;\n\n  for (const interceptor of interceptorList) {\n    interceptedResponse = await interceptor(interceptedResponse);\n  }\n\n  return interceptedResponse;\n}\n","import type { FetchResponse, RequestConfig } from './types';\n\nexport class ResponseErr extends Error {\n  response: FetchResponse;\n  request: RequestConfig;\n  config: RequestConfig;\n  status: number;\n  statusText: string;\n\n  constructor(\n    message: string,\n    requestInfo: RequestConfig,\n    response: FetchResponse,\n  ) {\n    super(message);\n\n    this.name = 'ResponseError';\n    this.message = message;\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.request = requestInfo;\n    this.config = requestInfo;\n    this.response = response;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  ErrorHandlingStrategy,\n  RequestHandlerConfig,\n  RequestConfig,\n  FetcherInstance,\n  Method,\n  RetryOptions,\n  FetchResponse,\n  ResponseError,\n  HeadersObject,\n} from './types/request-handler';\nimport type {\n  APIResponse,\n  QueryParams,\n  QueryParamsOrBody,\n  UrlPathParams,\n} from './types/api-handler';\nimport { interceptRequest, interceptResponse } from './interceptor-manager';\nimport { ResponseErr } from './response-error';\n\n/**\n * Generic Request Handler\n * It creates an Request Fetcher instance and handles requests within that instance\n * It handles errors depending on a chosen error handling strategy\n */\nexport class RequestHandler {\n  /**\n   * @var requestInstance Provider's instance\n   */\n  public requestInstance: FetcherInstance;\n\n  /**\n   * @var baseURL Base API url\n   */\n  public baseURL: string = '';\n\n  /**\n   * @var timeout Request timeout\n   */\n  public timeout: number = 30000;\n\n  /**\n   * @var cancellable Response cancellation\n   */\n  public cancellable: boolean = false;\n\n  /**\n   * @var rejectCancelled Whether to reject cancelled requests or not\n   */\n  public rejectCancelled: boolean = false;\n\n  /**\n   * @var strategy Request timeout\n   */\n  public strategy: ErrorHandlingStrategy = 'reject';\n\n  /**\n   * @var method Request method\n   */\n  public method: Method | string = 'get';\n\n  /**\n   * @var flattenResponse Response flattening\n   */\n  public flattenResponse: boolean = false;\n\n  /**\n   * @var defaultResponse Response flattening\n   */\n  public defaultResponse: any = null;\n\n  /**\n   * @var fetcher Request Fetcher instance\n   */\n  protected fetcher: FetcherInstance;\n\n  /**\n   * @var logger Logger\n   */\n  protected logger: any;\n\n  /**\n   * @var onError HTTP error service\n   */\n  protected onError: any;\n\n  /**\n   * @var requestsQueue    Queue of requests\n   */\n  protected requestsQueue: WeakMap<object, AbortController>;\n\n  /**\n   * Request Handler Config\n   */\n  protected retry: RetryOptions = {\n    retries: 0,\n    delay: 1000,\n    maxDelay: 30000,\n    backoff: 1.5,\n\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n    retryOn: [\n      408, // Request Timeout\n      409, // Conflict\n      425, // Too Early\n      429, // Too Many Requests\n      500, // Internal Server Error\n      502, // Bad Gateway\n      503, // Service Unavailable\n      504, // Gateway Timeout\n    ],\n\n    shouldRetry: async () => true,\n  };\n\n  /**\n   * Request Handler Config\n   */\n  public config: RequestHandlerConfig;\n\n  /**\n   * Creates an instance of RequestHandler.\n   *\n   * @param {Object} config - Configuration object for the request.\n   * @param {string} config.baseURL - The base URL for the request.\n   * @param {Object} config.endpoints - An object containing endpoint definitions.\n   * @param {number} config.timeout - You can set the timeout for particular request in milliseconds.\n   * @param {number} config.cancellable - If true, the previous requests will be automatically cancelled.\n   * @param {number} config.rejectCancelled - If true and request is set to cancellable, a cancelled request promise will be rejected. By default, instead of rejecting the promise, defaultResponse is returned.\n   * @param {number} config.timeout - Request timeout\n   * @param {string} config.strategy - Error Handling Strategy\n   * @param {string} config.flattenResponse - Whether to flatten response \"data\" object within \"data\" one\n   * @param {*} config.defaultResponse - Default response when there is no data or when endpoint fails depending on the chosen strategy. It's \"null\" by default\n   * @param {Object} [config.retry] - Options for retrying requests.\n   * @param {number} [config.retry.retries=0] - Number of retry attempts. No retries by default.\n   * @param {number} [config.retry.delay=1000] - Initial delay between retries in milliseconds.\n   * @param {number} [config.retry.backoff=1.5] - Exponential backoff factor.\n   * @param {number[]} [config.retry.retryOn=[502, 504, 408]] - HTTP status codes to retry on.\n   * @param {RequestInterceptor|RequestInterceptor[]} [config.onRequest] - Optional request interceptor function or an array of functions.\n   * These functions will be called with the request configuration object before the request is made. Can be used to modify or log the request configuration.\n   * @param {ResponseInterceptor|ResponseInterceptor[]} [config.onResponse] - Optional response interceptor function or an array of functions.\n   * These functions will be called with the response object after the response is received. an be used to modify or log the response data.\n   * @param {Function} [config.onError] - Optional callback function for handling errors.\n   * @param {Object} [config.headers] - Optional default headers to include in every request.\n   * @param {Object} config.fetcher - The Axios (or any other) instance to use for making requests.\n   * @param {*} config.logger - Instance of custom logger. Either class or an object similar to \"console\". Console is used by default.\n   */\n  public constructor({\n    fetcher = null,\n    timeout = null,\n    rejectCancelled = false,\n    strategy = null,\n    flattenResponse = null,\n    defaultResponse = {},\n    logger = null,\n    onError = null,\n    ...config\n  }: RequestHandlerConfig) {\n    this.fetcher = fetcher;\n    this.timeout =\n      timeout !== null && timeout !== undefined ? timeout : this.timeout;\n    this.strategy = strategy || this.strategy;\n    this.cancellable = config.cancellable || this.cancellable;\n    this.rejectCancelled = rejectCancelled || this.rejectCancelled;\n    this.flattenResponse = flattenResponse || this.flattenResponse;\n    this.defaultResponse = defaultResponse;\n    this.logger = logger || (globalThis ? globalThis.console : null) || null;\n    this.onError = onError;\n    this.requestsQueue = new WeakMap();\n    this.baseURL = config.baseURL || config.apiUrl || '';\n    this.method = config.method || this.method;\n    this.config = config;\n    this.retry = {\n      ...this.retry,\n      ...(config.retry || {}),\n    };\n\n    this.requestInstance = this.isCustomFetcher()\n      ? (fetcher as any).create({\n          ...config,\n          baseURL: this.baseURL,\n          timeout: this.timeout,\n        })\n      : null;\n  }\n\n  /**\n   * Get Provider Instance\n   *\n   * @returns {FetcherInstance} Provider's instance\n   */\n  public getInstance(): FetcherInstance {\n    return this.requestInstance;\n  }\n\n  /**\n   * Replaces dynamic URI parameters in a URL string with values from the provided `urlPathParams` object.\n   * Parameters in the URL are denoted by `:<paramName>`, where `<paramName>` is a key in `urlPathParams`.\n   *\n   * @param {string} url - The URL string containing placeholders in the format `:<paramName>`.\n   * @param {Object} urlPathParams - An object containing the parameter values to replace placeholders.\n   * @param {string} urlPathParams.paramName - The value to replace the placeholder `:<paramName>` in the URL.\n   * @returns {string} - The URL string with placeholders replaced by corresponding values from `urlPathParams`.\n   */\n  public replaceUrlPathParams(\n    url: string,\n    urlPathParams: UrlPathParams,\n  ): string {\n    if (!urlPathParams) {\n      return url;\n    }\n\n    return url.replace(/:[a-zA-Z]+/gi, (str): string => {\n      const word = str.substring(1);\n\n      return String(urlPathParams[word] ? urlPathParams[word] : str);\n    });\n  }\n\n  /**\n   * Appends query parameters to the given URL\n   *\n   * @param {string} url - The base URL to which query parameters will be appended.\n   * @param {QueryParams} params - An instance of URLSearchParams containing the query parameters to append.\n   * @returns {string} - The URL with the appended query parameters.\n   */\n  public appendQueryParams(url: string, params: QueryParams): string {\n    if (!params) {\n      return url;\n    }\n\n    // We don't use URLSearchParams here as we want to ensure that arrays are properly converted similarily to Axios\n    // So { foo: [1, 2] } would become: foo[]=1&foo[]=2\n    const queryString = Object.entries(params)\n      .flatMap(([key, value]) => {\n        if (Array.isArray(value)) {\n          return value.map(\n            (val) => `${encodeURIComponent(key)}[]=${encodeURIComponent(val)}`,\n          );\n        }\n        return `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;\n      })\n      .join('&');\n\n    return url.includes('?')\n      ? `${url}&${queryString}`\n      : queryString\n        ? `${url}?${queryString}`\n        : url;\n  }\n\n  /**\n   * Checks if a value is JSON serializable.\n   *\n   * JSON serializable values include:\n   * - Primitive types: string, number, boolean, null\n   * - Arrays\n   * - Plain objects (i.e., objects without special methods)\n   * - Values with a `toJSON` method\n   *\n   * @param {any} value - The value to check for JSON serializability.\n   * @returns {boolean} - Returns `true` if the value is JSON serializable, otherwise `false`.\n   */\n  protected isJSONSerializable(value: any): boolean {\n    if (value === undefined || value === null) {\n      return false;\n    }\n\n    const t = typeof value;\n    if (t === 'string' || t === 'number' || t === 'boolean') {\n      return true;\n    }\n\n    if (t !== 'object') {\n      return false; // bigint, function, symbol, undefined\n    }\n\n    if (Array.isArray(value)) {\n      return true;\n    }\n\n    if (Buffer.isBuffer(value)) {\n      return false;\n    }\n\n    if (value instanceof Date) {\n      return false;\n    }\n\n    const proto = Object.getPrototypeOf(value);\n\n    // Check if the prototype is `Object.prototype` or `null` (plain object)\n    if (proto === Object.prototype || proto === null) {\n      return true;\n    }\n\n    // Check if the object has a toJSON method\n    if (typeof value.toJSON === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Build request configuration\n   *\n   * @param {string} url                          Request url\n   * @param {QueryParamsOrBody} data    Request data\n   * @param {RequestConfig} config               Request config\n   * @returns {RequestConfig}                    Provider's instance\n   */\n  protected buildConfig(\n    url: string,\n    data: QueryParamsOrBody,\n    config: RequestConfig,\n  ): RequestConfig {\n    const method = config.method || this.method;\n    const methodLowerCase = method.toLowerCase();\n    const isGetAlikeMethod =\n      methodLowerCase === 'get' || methodLowerCase === 'head';\n\n    const dynamicUrl = this.replaceUrlPathParams(\n      url,\n      config.urlPathParams || this.config.urlPathParams,\n    );\n\n    // Bonus: Specifying it here brings support for \"body\" in Axios\n    const configData =\n      config.body || config.data || this.config.body || this.config.data;\n\n    // Axios compatibility\n    if (this.isCustomFetcher()) {\n      return {\n        ...config,\n        url: dynamicUrl,\n        method: methodLowerCase,\n\n        ...(isGetAlikeMethod ? { params: data } : {}),\n\n        // For POST requests body payload is the first param for convenience (\"data\")\n        // In edge cases we want to split so to treat it as query params, and use \"body\" coming from the config instead\n        ...(!isGetAlikeMethod && data && configData ? { params: data } : {}),\n\n        // Only applicable for request methods 'PUT', 'POST', 'DELETE', and 'PATCH'\n        ...(!isGetAlikeMethod && data && !configData ? { data } : {}),\n        ...(!isGetAlikeMethod && configData ? { data: configData } : {}),\n      };\n    }\n\n    // Native fetch\n    const payload = configData || data;\n    const credentials =\n      config.withCredentials || this.config.withCredentials\n        ? 'include'\n        : config.credentials;\n\n    delete config.data;\n    delete config.withCredentials;\n\n    const urlPath =\n      (!isGetAlikeMethod && data && !config.body) || !data\n        ? dynamicUrl\n        : this.appendQueryParams(dynamicUrl, data);\n    const isFullUrl = urlPath.includes('://');\n    const baseURL = isFullUrl\n      ? ''\n      : typeof config.baseURL !== 'undefined'\n        ? config.baseURL\n        : this.baseURL;\n\n    return {\n      ...config,\n      credentials,\n\n      // Native fetch generally requires query params to be appended in the URL\n      // Do not append query params only if it's a POST-alike request with only \"data\" specified as it's treated as body payload\n      url: baseURL + urlPath,\n\n      // Uppercase method name\n      method: method.toUpperCase(),\n\n      // For convenience, add the same default headers as Axios does\n      headers: {\n        Accept: 'application/json, text/plain, */*',\n        'Content-Type': 'application/json;charset=utf-8',\n        ...(config.headers || this.config.headers || {}),\n      },\n\n      // Automatically JSON stringify request bodies, if possible and when not dealing with strings\n      ...(!isGetAlikeMethod\n        ? {\n            body:\n              !(payload instanceof URLSearchParams) &&\n              this.isJSONSerializable(payload)\n                ? typeof payload === 'string'\n                  ? payload\n                  : JSON.stringify(payload)\n                : payload,\n          }\n        : {}),\n    };\n  }\n\n  /**\n   * Process global Request Error\n   *\n   * @param {ResponseError} error      Error instance\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {void}\n   */\n  protected processError(\n    error: ResponseError,\n    requestConfig: RequestConfig,\n  ): void {\n    if (this.isRequestCancelled(error)) {\n      return;\n    }\n\n    if (this.logger?.warn) {\n      this.logger.warn('API ERROR', error);\n    }\n\n    // Invoke per request \"onError\" interceptor\n    if (requestConfig.onError && typeof requestConfig.onError === 'function') {\n      requestConfig.onError(error);\n    }\n\n    // Invoke global \"onError\" interceptor\n    if (this.onError && typeof this.onError === 'function') {\n      this.onError(error);\n    }\n  }\n\n  /**\n   * Output default response in case of an error, depending on chosen strategy\n   *\n   * @param {ResponseError} error      Error instance\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {*} Error response\n   */\n  protected async outputErrorResponse(\n    error: ResponseError,\n    requestConfig: RequestConfig,\n  ): Promise<any> {\n    const isRequestCancelled = this.isRequestCancelled(error);\n    const errorHandlingStrategy = requestConfig.strategy || this.strategy;\n    const rejectCancelled =\n      typeof requestConfig.rejectCancelled !== 'undefined'\n        ? requestConfig.rejectCancelled\n        : this.rejectCancelled;\n    const defaultResponse =\n      typeof requestConfig.defaultResponse !== 'undefined'\n        ? requestConfig.defaultResponse\n        : this.defaultResponse;\n\n    // Output full response with the error object\n    if (errorHandlingStrategy === 'softFail') {\n      return this.outputResponse(error.response, requestConfig, error);\n    }\n\n    // By default cancelled requests aren't rejected\n    if (isRequestCancelled && !rejectCancelled) {\n      return defaultResponse;\n    }\n\n    // Hang the promise\n    if (errorHandlingStrategy === 'silent') {\n      await new Promise(() => null);\n\n      return defaultResponse;\n    }\n\n    // Reject the promise\n    if (errorHandlingStrategy === 'reject') {\n      return Promise.reject(error);\n    }\n\n    return defaultResponse;\n  }\n\n  /**\n   * Output error response depending on chosen strategy\n   *\n   * @param {ResponseError} error               Error instance\n   * @returns {boolean}                        True if request is aborted\n   */\n  public isRequestCancelled(error: ResponseError): boolean {\n    return error.name === 'AbortError' || error.name === 'CanceledError';\n  }\n\n  /**\n   * Detects if a custom fetcher is utilized\n   *\n   * @returns {boolean}                        True if it's a custom fetcher\n   */\n  protected isCustomFetcher(): boolean {\n    return this.fetcher !== null;\n  }\n\n  /**\n   * Automatically Cancel Previous Requests using AbortController when \"cancellable\" is defined\n   *\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {Object} Controller Signal to abort\n   */\n  protected addCancellationToken(\n    requestConfig: RequestConfig,\n  ): Partial<Record<'signal', AbortSignal>> {\n    // Both disabled\n    if (!this.cancellable && !requestConfig.cancellable) {\n      return {};\n    }\n\n    // Explicitly disabled per request\n    if (\n      typeof requestConfig.cancellable !== 'undefined' &&\n      !requestConfig.cancellable\n    ) {\n      return {};\n    }\n\n    // Check if AbortController is available\n    if (typeof AbortController === 'undefined') {\n      console.error('AbortController is unavailable.');\n\n      return {};\n    }\n\n    // Generate unique key as a cancellation token\n    const previousRequest = this.requestsQueue.get(requestConfig);\n\n    if (previousRequest) {\n      previousRequest.abort();\n    }\n\n    const controller = new AbortController();\n\n    // Introduce timeout for native fetch\n    if (!this.isCustomFetcher() && this.timeout > 0) {\n      const abortTimeout = setTimeout(() => {\n        const error = new Error(\n          `[TimeoutError]: The ${requestConfig.url} request was aborted due to timeout`,\n        );\n\n        error.name = 'TimeoutError';\n        (error as any).code = 23; // DOMException.TIMEOUT_ERR\n        controller.abort(error);\n        clearTimeout(abortTimeout);\n        throw error;\n      }, requestConfig.timeout || this.timeout);\n    }\n\n    this.requestsQueue.set(requestConfig, controller);\n\n    return {\n      signal: controller.signal,\n    };\n  }\n\n  /**\n   * Handle Request depending on used strategy\n   *\n   * @param {string} url - Request url\n   * @param {QueryParamsOrBody} data - Request data\n   * @param {RequestConfig} config - Request config\n   * @param {RequestConfig} payload.config               Request config\n   * @throws {ResponseError}\n   * @returns {Promise<ResponseData & FetchResponse<ResponseData>>} Response Data\n   */\n  public async request<ResponseData = APIResponse>(\n    url: string,\n    data: QueryParamsOrBody = null,\n    config: RequestConfig = null,\n  ): Promise<ResponseData & FetchResponse<ResponseData>> {\n    let response: FetchResponse<ResponseData> = null;\n    const _config = config || {};\n    const _requestConfig = this.buildConfig(url, data, _config);\n\n    let requestConfig: RequestConfig = {\n      ...this.addCancellationToken(_requestConfig),\n      ..._requestConfig,\n    };\n\n    const { retries, delay, backoff, retryOn, shouldRetry, maxDelay } = {\n      ...this.retry,\n      ...(requestConfig?.retry || {}),\n    };\n\n    let attempt = 0;\n    let waitTime = delay;\n\n    while (attempt <= retries) {\n      try {\n        // Local interceptors\n        requestConfig = await interceptRequest(\n          requestConfig,\n          requestConfig.onRequest,\n        );\n\n        // Global interceptors\n        requestConfig = await interceptRequest(\n          requestConfig,\n          this.config.onRequest,\n        );\n\n        // Axios compatibility\n        if (this.isCustomFetcher()) {\n          response = (await (this.requestInstance as any).request(\n            requestConfig,\n          )) as FetchResponse<ResponseData>;\n        } else {\n          response = (await globalThis.fetch(\n            requestConfig.url,\n            requestConfig,\n          )) as FetchResponse<ResponseData>;\n\n          // Attempt to collect response data regardless of response status\n          const contentType = String(\n            (response as Response)?.headers?.get('Content-Type') || '',\n          );\n          let data;\n          const responseClone = response.clone();\n\n          // Handle edge case of no content type being provided... We assume json here.\n          if (!contentType) {\n            try {\n              data = await responseClone.json();\n              // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            } catch (_error) {\n              //\n            }\n          }\n\n          if (typeof data === 'undefined') {\n            if (\n              contentType &&\n              (contentType.includes('application/json') ||\n                // This Media Type Suffix is standardizded by IETF in RFC 6839\n                contentType.includes('+json'))\n            ) {\n              data = await response.json(); // Parse JSON response\n            } else if (contentType.includes('multipart/form-data')) {\n              data = await response.formData(); // Parse as FormData\n            } else if (contentType.includes('application/octet-stream')) {\n              data = await response.blob(); // Parse as blob\n            } else if (\n              contentType.includes('application/x-www-form-urlencoded')\n            ) {\n              data = await response.formData(); // Handle URL-encoded forms\n            } else if (typeof response.text !== 'undefined') {\n              data = await response.text();\n            } else {\n              // Handle streams\n              data = response.body || response.data || null;\n            }\n          }\n\n          // Add more information to response object\n          response.config = requestConfig;\n          response.data = data;\n\n          // Check if the response status is not outside the range 200-299 and if so, output error\n          if (!response.ok) {\n            throw new ResponseErr(\n              `${requestConfig.url} failed! Status: ${response.status || null}`,\n              requestConfig,\n              response,\n            );\n          }\n        }\n\n        // Local interceptors\n        response = await interceptResponse(response, requestConfig.onResponse);\n\n        // Global interceptors\n        response = await interceptResponse(response, this.config.onResponse);\n\n        return this.outputResponse(response, requestConfig) as ResponseData &\n          FetchResponse<ResponseData>;\n      } catch (error) {\n        if (\n          attempt === retries ||\n          !(await shouldRetry(error, attempt)) ||\n          !retryOn?.includes(error?.response?.status || error?.status)\n        ) {\n          this.processError(error, requestConfig);\n\n          return this.outputErrorResponse(error, requestConfig);\n        }\n\n        if (this.logger?.warn) {\n          this.logger.warn(\n            `Attempt ${attempt + 1} failed. Retrying in ${waitTime}ms...`,\n          );\n        }\n\n        await this.delay(waitTime);\n\n        waitTime *= backoff;\n        waitTime = Math.min(waitTime, maxDelay);\n        attempt++;\n      }\n    }\n\n    return this.outputResponse(response, requestConfig) as ResponseData &\n      FetchResponse<ResponseData>;\n  }\n\n  public async delay(ms: number): Promise<boolean> {\n    return new Promise((resolve) =>\n      setTimeout(() => {\n        return resolve(true);\n      }, ms),\n    );\n  }\n\n  public processHeaders<ResponseData>(\n    response: FetchResponse<ResponseData>,\n  ): HeadersObject {\n    if (!response.headers) {\n      return {};\n    }\n\n    let headersObject: HeadersObject = {};\n\n    // Handle Headers object with entries() method\n    if (response.headers instanceof Headers) {\n      for (const [key, value] of (response.headers as any).entries()) {\n        headersObject[key] = value;\n      }\n    } else {\n      // Handle plain object\n      headersObject = { ...(response.headers as HeadersObject) };\n    }\n\n    return headersObject;\n  }\n\n  /**\n   * Output response\n   *\n   * @param response - Response payload\n   * @param {RequestConfig} requestConfig - Request config\n   * @param {*} error - whether the response is erroneous\n   * @returns {ResponseData | FetchResponse<ResponseData>} Response data\n   */\n  protected outputResponse<ResponseData = APIResponse>(\n    response: FetchResponse<ResponseData>,\n    requestConfig: RequestConfig,\n    error = null,\n  ): ResponseData | FetchResponse<ResponseData> {\n    const defaultResponse =\n      typeof requestConfig.defaultResponse !== 'undefined'\n        ? requestConfig.defaultResponse\n        : this.defaultResponse;\n\n    if (!response) {\n      return defaultResponse;\n    }\n\n    if (\n      (requestConfig.flattenResponse || this.flattenResponse) &&\n      typeof response.data !== 'undefined'\n    ) {\n      // Special case of only data property within response data object (happens in Axios)\n      // This is in fact a proper response but we may want to flatten it\n      // To ease developers' lives when obtaining the response\n      if (\n        response.data !== null &&\n        typeof response.data === 'object' &&\n        typeof (response.data as any).data !== 'undefined' &&\n        Object.keys(response.data).length === 1\n      ) {\n        return (response.data as any).data;\n      }\n\n      return response.data;\n    }\n\n    // If empty object is returned, ensure that the default response is used instead\n    if (\n      response !== null &&\n      typeof response === 'object' &&\n      response.constructor === Object &&\n      Object.keys(response).length === 0\n    ) {\n      return defaultResponse;\n    }\n\n    const isCustomFetcher = this.isCustomFetcher();\n\n    if (isCustomFetcher) {\n      return response;\n    }\n\n    if (error !== null) {\n      delete error?.response;\n      delete error?.request;\n      delete error?.config;\n    }\n\n    // Native fetch()\n    return {\n      body: response.body,\n      blob: response.blob,\n      json: response.json,\n      text: response.text,\n      clone: response.clone,\n      bodyUsed: response.bodyUsed,\n      arrayBuffer: response.arrayBuffer,\n      formData: response.formData,\n      ok: response.ok,\n      redirected: response.redirected,\n      type: response.type,\n      url: response.url,\n      status: response.status,\n      statusText: response.statusText,\n\n      // Extend with extra information\n      error,\n      data: response.data,\n      headers: this.processHeaders(response),\n      config: requestConfig,\n    };\n  }\n}\n","import { RequestHandler } from './request-handler';\nimport type {\n  FetcherInstance,\n  RequestConfig,\n  FetchResponse,\n} from './types/request-handler';\nimport type {\n  ApiHandlerConfig,\n  ApiHandlerMethods,\n  ApiHandlerReturnType,\n  APIResponse,\n  QueryParams,\n  UrlPathParams,\n} from './types/api-handler';\n\n/**\n * Creates an instance of API Handler.\n * It creates an API fetcher function using native fetch() or Axios if it is passed as \"fetcher\".\n *\n * @param {Object} config - Configuration object for the API fetcher.\n * @param {string} config.apiUrl - The base URL for the API.\n * @param {Object} config.endpoints - An object containing endpoint definitions.\n * @param {number} config.timeout - You can set the timeout for particular request in milliseconds.\n * @param {number} config.cancellable - If true, the previous requests will be automatically cancelled.\n * @param {number} config.rejectCancelled - If true and request is set to cancellable, a cancelled request promise will be rejected. By default, instead of rejecting the promise, defaultResponse is returned.\n * @param {number} config.timeout - Request timeout\n * @param {string} config.strategy - Error Handling Strategy\n * @param {string} config.flattenResponse - Whether to flatten response \"data\" object within \"data\" one\n * @param {*} config.defaultResponse - Default response when there is no data or when endpoint fails depending on the chosen strategy. It's \"null\" by default\n * @param {Object} [config.retry] - Options for retrying requests.\n * @param {number} [config.retry.retries=0] - Number of retry attempts. No retries by default.\n * @param {number} [config.retry.delay=1000] - Initial delay between retries in milliseconds.\n * @param {number} [config.retry.backoff=1.5] - Exponential backoff factor.\n * @param {number[]} [config.retry.retryOn=[502, 504, 408]] - HTTP status codes to retry on.\n * @param {RequestInterceptor|RequestInterceptor[]} [config.onRequest] - Optional request interceptor function or an array of functions.\n * These functions will be called with the request configuration object before the request is made. Can be used to modify or log the request configuration.\n * @param {ResponseInterceptor|ResponseInterceptor[]} [config.onResponse] - Optional response interceptor function or an array of functions.\n * These functions will be called with the response object after the response is received. an be used to modify or log the response data.\n * @param {Function} [config.onError] - Optional callback function for handling errors.\n * @param {Object} [config.headers] - Optional default headers to include in every request.\n * @param {Object} config.fetcher - The Axios (or any other) instance to use for making requests.\n * @param {*} config.logger - Instance of custom logger. Either class or an object similar to \"console\". Console is used by default.\n * @returns API handler functions and endpoints to call\n *\n * @example\n * // Import axios (optional)\n * import axios from 'axios';\n *\n * // Define endpoint paths\n * const endpoints = {\n *   getUser: '/user',\n *   createPost: '/post',\n * };\n *\n * // Create the API fetcher with configuration\n * const api = createApiFetcher({\n *   fetcher: axios, // Axios instance (optional)\n *   endpoints,\n *   apiUrl: 'https://example.com/api',\n *   onError(error) {\n *     console.log('Request failed', error);\n *   },\n *   headers: {\n *     'my-auth-key': 'example-auth-key-32rjjfa',\n *   },\n * });\n *\n * // Fetch user data\n * const response = await api.getUser({ userId: 1, ratings: [1, 2] })\n */\nfunction createApiFetcher<\n  EndpointsMethods extends object,\n  EndpointsCfg = never,\n>(config: ApiHandlerConfig<EndpointsMethods>) {\n  const endpoints = config.endpoints;\n  const requestHandler = new RequestHandler(config);\n\n  /**\n   * Get Fetcher Provider Instance\n   *\n   * @returns {FetcherInstance} Request Handler's Fetcher instance\n   */\n  function getInstance(): FetcherInstance {\n    return requestHandler.getInstance();\n  }\n\n  /**\n   * Triggered when trying to use non-existent endpoints\n   *\n   * @param endpointName Endpoint Name\n   * @returns {Promise}\n   */\n  function handleNonImplemented(endpointName: string): Promise<null> {\n    console.error(`${endpointName} endpoint must be added to 'endpoints'.`);\n\n    return Promise.resolve(null);\n  }\n\n  /**\n   * Handle Single API Request\n   * It considers settings in following order: per-request settings, global per-endpoint settings, global settings.\n   *\n   * @param {string} endpointName - The name of the API endpoint to call.\n   * @param {QueryParams} [queryParams={}] - Query parameters to include in the request.\n   * @param {UrlPathParams} [urlPathParams={}] - URI parameters to include in the request.\n   * @param {EndpointConfig} [requestConfig={}] - Additional configuration for the request.\n   * @returns {Promise<Response & FetchResponse>} - A promise that resolves with the response from the API provider.\n   */\n  async function request<Response = APIResponse>(\n    endpointName: keyof EndpointsMethods | string,\n    queryParams: QueryParams = {},\n    urlPathParams: UrlPathParams = {},\n    requestConfig: RequestConfig = {},\n  ): Promise<Response & FetchResponse<Response>> {\n    // Use global per-endpoint settings\n    const endpointConfig = endpoints[endpointName as string];\n    const endpointSettings = { ...endpointConfig };\n\n    const responseData = await requestHandler.request<Response>(\n      endpointSettings.url,\n      queryParams,\n      {\n        ...endpointSettings,\n        ...requestConfig,\n        urlPathParams,\n      },\n    );\n\n    return responseData;\n  }\n\n  /**\n   * Maps all API requests using native Proxy\n   *\n   * @param {*} prop          Caller\n   */\n  function get(prop: string | symbol) {\n    if (prop in apiHandler) {\n      return apiHandler[prop];\n    }\n\n    // Prevent handler from triggering non-existent endpoints\n    if (!endpoints[prop as string]) {\n      return handleNonImplemented.bind(null, prop);\n    }\n\n    return apiHandler.request.bind(null, prop);\n  }\n\n  const apiHandler: ApiHandlerMethods<EndpointsMethods> = {\n    config,\n    endpoints,\n    requestHandler,\n    getInstance,\n    request,\n  };\n\n  return new Proxy(apiHandler, {\n    get: (_target, prop) => get(prop),\n  }) as ApiHandlerReturnType<EndpointsMethods, EndpointsCfg>;\n}\n\nexport { createApiFetcher };\n"],"mappings":"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","names":["src_exports","__export","createApiFetcher","fetchf","__toCommonJS","interceptRequest","config","interceptors","interceptorList","interceptedConfig","interceptor","interceptResponse","response","interceptedResponse","ResponseErr","message","requestInfo","response","RequestHandler","fetcher","timeout","rejectCancelled","strategy","flattenResponse","defaultResponse","logger","onError","config","url","urlPathParams","str","word","params","queryString","key","value","val","proto","data","method","methodLowerCase","isGetAlikeMethod","dynamicUrl","configData","payload","credentials","urlPath","baseURL","error","requestConfig","_a","isRequestCancelled","errorHandlingStrategy","previousRequest","controller","abortTimeout","_b","_c","response","_config","_requestConfig","retries","delay","backoff","retryOn","shouldRetry","maxDelay","attempt","waitTime","interceptRequest","contentType","responseClone","ResponseErr","interceptResponse","ms","resolve","headersObject","createApiFetcher","config","endpoints","requestHandler","RequestHandler","getInstance","handleNonImplemented","endpointName","request","queryParams","urlPathParams","requestConfig","endpointSettings","get","prop","apiHandler","_target","fetchf","url","config","RequestHandler"]}