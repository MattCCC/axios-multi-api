{"version":3,"sources":["../src/index.ts","../src/interceptor-manager.ts","../src/response-error.ts","../src/utils.ts","../src/queue-manager.ts","../src/request-handler.ts","../src/api-handler.ts"],"sourcesContent":["import { RequestHandler } from './request-handler';\nimport type { APIResponse, FetchResponse, RequestHandlerConfig } from './types';\n\n/**\n * Simple wrapper for request fetching.\n * It abstracts the creation of RequestHandler, making it easy to perform API requests.\n *\n * @param {string | URL | globalThis.Request} url - Request URL.\n * @param {RequestHandlerConfig} config - Configuration object for the request handler.\n * @returns {Promise<ResponseData & FetchResponse<ResponseData>>} Response Data.\n */\nexport async function fetchf<ResponseData = APIResponse>(\n  url: string,\n  config: RequestHandlerConfig = {},\n): Promise<ResponseData & FetchResponse<ResponseData>> {\n  return new RequestHandler(config).request<ResponseData>(url, null, config);\n}\n\nexport * from './types';\nexport * from './api-handler';\n","import type { RequestHandlerConfig, FetchResponse } from './types';\nimport type {\n  RequestInterceptor,\n  ResponseInterceptor,\n} from './types/interceptor-manager';\n\n/**\n * Applies a series of request interceptors to the provided configuration.\n * @param {RequestHandlerConfig} config - The initial request configuration.\n * @param {RequestInterceptor | RequestInterceptor[]} interceptors - The request interceptor function(s) to apply.\n * @returns {Promise<RequestHandlerConfig>} - The modified request configuration.\n */\nexport async function interceptRequest(\n  config: RequestHandlerConfig,\n  interceptors: RequestInterceptor | RequestInterceptor[],\n): Promise<RequestHandlerConfig> {\n  if (!interceptors) {\n    return config;\n  }\n\n  const interceptorList = Array.isArray(interceptors)\n    ? interceptors\n    : [interceptors];\n\n  let interceptedConfig = { ...config };\n\n  for (const interceptor of interceptorList) {\n    interceptedConfig = await interceptor(interceptedConfig);\n  }\n\n  return interceptedConfig;\n}\n\n/**\n * Applies a series of response interceptors to the provided response.\n * @param {FetchResponse<ResponseData>} response - The initial response object.\n * @param {ResponseInterceptor | ResponseInterceptor[]} interceptors - The response interceptor function(s) to apply.\n * @returns {Promise<FetchResponse<ResponseData>>} - The modified response object.\n */\nexport async function interceptResponse<ResponseData = unknown>(\n  response: FetchResponse<ResponseData>,\n  interceptors: ResponseInterceptor | ResponseInterceptor[],\n): Promise<FetchResponse<ResponseData>> {\n  if (!interceptors) {\n    return response;\n  }\n\n  const interceptorList = Array.isArray(interceptors)\n    ? interceptors\n    : [interceptors];\n\n  let interceptedResponse = response;\n\n  for (const interceptor of interceptorList) {\n    interceptedResponse = await interceptor(interceptedResponse);\n  }\n\n  return interceptedResponse;\n}\n","import type { FetchResponse, RequestConfig } from './types';\n\nexport class ResponseErr extends Error {\n  response: FetchResponse;\n  request: RequestConfig;\n  config: RequestConfig;\n  status: number;\n  statusText: string;\n\n  constructor(\n    message: string,\n    requestInfo: RequestConfig,\n    response: FetchResponse,\n  ) {\n    super(message);\n\n    this.name = 'ResponseError';\n    this.message = message;\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.request = requestInfo;\n    this.config = requestInfo;\n    this.response = response;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { QueryParams, UrlPathParams } from './types';\n\n/**\n * Appends query parameters to a given URL.\n *\n * @param {string} url - The base URL to which query parameters will be appended.\n * @param {QueryParams} params - An object containing the query parameters to append.\n * @returns {string} - The URL with the appended query parameters.\n */\nexport function appendQueryParams(url: string, params: QueryParams): string {\n  if (!params) {\n    return url;\n  }\n\n  // Check if `params` is an instance of URLSearchParams and bail early if it is\n  if (params instanceof URLSearchParams) {\n    const encodedQueryString = params.toString();\n\n    return url.includes('?')\n      ? `${url}&${encodedQueryString}`\n      : encodedQueryString\n        ? `${url}?${encodedQueryString}`\n        : url;\n  }\n\n  // This is exact copy of what JQ used to do. It works much better than URLSearchParams\n  const s = [];\n  const add = function (k: string, v: any) {\n    v = typeof v === 'function' ? v() : v;\n    v = v === null ? '' : v === undefined ? '' : v;\n    s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v);\n  };\n\n  const buildParams = (prefix: string, obj: any) => {\n    let i: number, len: number, key: string;\n\n    if (prefix) {\n      if (Array.isArray(obj)) {\n        for (i = 0, len = obj.length; i < len; i++) {\n          buildParams(\n            prefix +\n              '[' +\n              (typeof obj[i] === 'object' && obj[i] ? i : '') +\n              ']',\n            obj[i],\n          );\n        }\n      } else if (typeof obj === 'object' && obj !== null) {\n        for (key in obj) {\n          buildParams(prefix + '[' + key + ']', obj[key]);\n        }\n      } else {\n        add(prefix, obj);\n      }\n    } else if (Array.isArray(obj)) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        add(obj[i].name, obj[i].value);\n      }\n    } else {\n      for (key in obj) {\n        buildParams(key, obj[key]);\n      }\n    }\n    return s;\n  };\n\n  const queryStringParts = buildParams('', params).join('&');\n\n  // Encode special characters as per RFC 3986, https://datatracker.ietf.org/doc/html/rfc3986\n  const encodedQueryString = queryStringParts.replace(/%5B%5D/g, '[]'); // Keep '[]' for arrays\n\n  return url.includes('?')\n    ? `${url}&${encodedQueryString}`\n    : encodedQueryString\n      ? `${url}?${encodedQueryString}`\n      : url;\n}\n\n/**\n * Replaces dynamic URI parameters in a URL string with values from the provided `urlPathParams` object.\n * Parameters in the URL are denoted by `:<paramName>`, where `<paramName>` is a key in `urlPathParams`.\n *\n * @param {string} url - The URL string containing placeholders in the format `:<paramName>`.\n * @param {Object} urlPathParams - An object containing the parameter values to replace placeholders.\n * @param {string} urlPathParams.paramName - The value to replace the placeholder `:<paramName>` in the URL.\n * @returns {string} - The URL string with placeholders replaced by corresponding values from `urlPathParams`.\n */\nexport function replaceUrlPathParams(\n  url: string,\n  urlPathParams: UrlPathParams,\n): string {\n  if (!urlPathParams) {\n    return url;\n  }\n\n  return url.replace(/:[a-zA-Z]+/gi, (str): string => {\n    const word = str.substring(1);\n\n    return String(urlPathParams[word] ? urlPathParams[word] : str);\n  });\n}\n\n/**\n * Checks if a value is JSON serializable.\n *\n * JSON serializable values include:\n * - Primitive types: string, number, boolean, null\n * - Arrays\n * - Plain objects (i.e., objects without special methods)\n * - Values with a `toJSON` method\n *\n * @param {any} value - The value to check for JSON serializability.\n * @returns {boolean} - Returns `true` if the value is JSON serializable, otherwise `false`.\n */\nexport function isJSONSerializable(value: any): boolean {\n  if (value === undefined || value === null) {\n    return false;\n  }\n\n  const t = typeof value;\n  if (t === 'string' || t === 'number' || t === 'boolean') {\n    return true;\n  }\n\n  if (t !== 'object') {\n    return false; // bigint, function, symbol, undefined\n  }\n\n  if (Array.isArray(value)) {\n    return true;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return false;\n  }\n\n  if (value instanceof Date) {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value);\n\n  // Check if the prototype is `Object.prototype` or `null` (plain object)\n  if (proto === Object.prototype || proto === null) {\n    return true;\n  }\n\n  // Check if the object has a toJSON method\n  if (typeof value.toJSON === 'function') {\n    return true;\n  }\n\n  return false;\n}\n\nexport async function delayInvocation(ms: number): Promise<boolean> {\n  return new Promise((resolve) =>\n    setTimeout(() => {\n      return resolve(true);\n    }, ms),\n  );\n}\n","import type { RequestConfig } from './types';\nimport type { QueueItem, RequestsQueue } from './types/queue-manager';\n\n/**\n * Queue Manager is responsible for managing and controlling the flow of concurrent or sequential requests. It handles:\n * - Request Queueing and Deduplication\n * - Request Timeout Handling\n * - Abort Controller Management and Request Cancellation\n * - Concurrency Control and Locking\n * - Request Lifecycle Management\n */\nconst queue: RequestsQueue = new WeakMap<RequestConfig, QueueItem>();\nconst locks = new WeakMap<object, Promise<void>>();\n\n/**\n * Ensures that the operation on the queue is performed atomically.\n *\n * @param fn - The function to be executed with lock.\n * @returns {Promise<void>} - A promise that resolves when the operation is complete.\n */\nexport async function withLock<T>(\n  key: object,\n  fn: () => Promise<T>,\n): Promise<T> {\n  let release: () => void;\n  const lock = new Promise<void>((resolve) => (release = resolve));\n\n  // Wait for existing locks to be released\n  if (locks.has(key)) {\n    await locks.get(key);\n  }\n\n  locks.set(key, lock);\n\n  try {\n    return await fn();\n  } finally {\n    release();\n    locks.delete(key);\n  }\n}\n\n/**\n * Adds a request to the queue if it's not already being processed within the dedupeTime interval.\n *\n * @param {RequestConfig} config - The request configuration object.\n * @param {number} timeout - Timeout in milliseconds for the request.\n * @param {number} dedupeTime - Deduplication time in milliseconds.\n * @param {boolean} isCancellable - If true, then the previous request with same configuration should be aborted.\n * @param {boolean} resetTimeout - Whether to reset the timeout.\n * @returns {Promise<AbortController>} - A promise that resolves to an AbortController.\n */\nexport async function addRequest(\n  config: RequestConfig,\n  timeout: number,\n  dedupeTime: number = 0,\n  isCancellable: boolean = false,\n  resetTimeout: boolean = false,\n): Promise<AbortController> {\n  return withLock(config, async () => {\n    const now = Date.now();\n    const existingItem = queue.get(config);\n\n    if (existingItem) {\n      // If the request is already in the queue and within the dedupeTime, reuse the existing controller\n      if (now - existingItem.timestamp < dedupeTime) {\n        return existingItem.controller;\n      }\n\n      // Abort previous request, if applicable, and continue as usual\n      if (isCancellable) {\n        existingItem.controller.abort();\n      }\n\n      // If the request is too old, remove it and proceed to add a new one\n      removeRequest(config);\n    }\n\n    // Create a new AbortController and add the request to the queue\n    const controller = new AbortController();\n\n    // Set up a timeout to automatically abort the request if it exceeds the specified time.\n    const timeoutId =\n      // Timeout might be already set and we may not want to reset it, so do not create it when \"resetTimeout\" is set to \"true\"\n      timeout > 0 && !resetTimeout\n        ? setTimeout(() => {\n            const error = new Error(`${config.url} aborted due to timeout`);\n            error.name = 'TimeoutError';\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (error as any).code = 23; // DOMException.TIMEOUT_ERR\n\n            controller.abort(error);\n            removeRequest(config);\n          }, timeout)\n        : null;\n\n    queue.set(config, { controller, timeoutId, timestamp: now });\n    return controller;\n  });\n}\n\n/**\n * Removes a request from the queue and clears its timeout.\n *\n * @param config - The request configuration.\n */\nexport async function removeRequest(config: RequestConfig): Promise<void> {\n  await withLock(config, async () => {\n    const item = queue.get(config);\n\n    if (item) {\n      if (item.timeoutId !== null) {\n        clearTimeout(item.timeoutId);\n      }\n      queue.delete(config);\n    }\n  });\n}\n\n/**\n * Gets the AbortController for a request configuration.\n *\n * @param config - The request configuration.\n * @returns {AbortController | undefined} - The AbortController or undefined.\n */\nexport async function getController(\n  config: RequestConfig,\n): Promise<AbortController | undefined> {\n  let controller: AbortController | undefined;\n\n  await withLock(config, async () => {\n    const item = queue.get(config);\n    controller = item?.controller;\n  });\n\n  return controller;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  ErrorHandlingStrategy,\n  RequestHandlerConfig,\n  RequestConfig,\n  FetcherInstance,\n  Method,\n  RetryOptions,\n  FetchResponse,\n  ResponseError,\n  HeadersObject,\n} from './types/request-handler';\nimport type {\n  APIResponse,\n  BodyPayload,\n  QueryParams,\n  QueryParamsOrBody,\n} from './types/api-handler';\nimport { interceptRequest, interceptResponse } from './interceptor-manager';\nimport { ResponseErr } from './response-error';\nimport {\n  appendQueryParams,\n  isJSONSerializable,\n  replaceUrlPathParams,\n  delayInvocation,\n} from './utils';\nimport { addRequest, removeRequest } from './queue-manager';\n\nconst APPLICATION_JSON = 'application/json';\n\n/**\n * Generic Request Handler\n * It creates an Request Fetcher instance and handles requests within that instance\n * It handles errors depending on a chosen error handling strategy\n */\nexport class RequestHandler {\n  public requestInstance: FetcherInstance;\n  public baseURL: string = '';\n  public timeout: number = 30000;\n  public strategy: ErrorHandlingStrategy = 'reject';\n  public method: Method | string = 'get';\n  public flattenResponse: boolean = false;\n  public defaultResponse: any = null;\n  protected fetcher: FetcherInstance;\n  protected logger: any;\n  protected retry: RetryOptions = {\n    retries: 0,\n    delay: 1000,\n    maxDelay: 30000,\n    resetTimeout: true,\n    backoff: 1.5,\n\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n    retryOn: [\n      408, // Request Timeout\n      409, // Conflict\n      425, // Too Early\n      429, // Too Many Requests\n      500, // Internal Server Error\n      502, // Bad Gateway\n      503, // Service Unavailable\n      504, // Gateway Timeout\n    ],\n\n    shouldRetry: async () => true,\n  };\n  public config: RequestHandlerConfig = {};\n\n  public constructor({\n    fetcher = null,\n    timeout = null,\n    strategy = null,\n    flattenResponse = null,\n    defaultResponse = {},\n    logger = null,\n    ...config\n  }: RequestHandlerConfig) {\n    this.fetcher = fetcher;\n    this.timeout =\n      timeout !== null && timeout !== undefined ? timeout : this.timeout;\n    this.strategy = strategy || this.strategy;\n    this.flattenResponse = flattenResponse || this.flattenResponse;\n    this.defaultResponse = defaultResponse;\n    this.logger = logger || null;\n    this.baseURL = config.baseURL || config.apiUrl || '';\n    this.method = config.method || this.method;\n    this.config = {\n      rejectCancelled: false,\n      dedupeTime: 1000,\n      ...config,\n    };\n    this.retry = {\n      ...this.retry,\n      ...(config.retry || {}),\n    };\n\n    this.requestInstance = this.isCustomFetcher()\n      ? (fetcher as any).create({\n          ...config,\n          baseURL: this.baseURL,\n          timeout: this.timeout,\n        })\n      : null;\n  }\n\n  /**\n   * Get Provider Instance\n   *\n   * @returns {FetcherInstance} Provider's instance\n   */\n  public getInstance(): FetcherInstance {\n    return this.requestInstance;\n  }\n\n  /**\n   * Build request configuration\n   *\n   * @param {string} url - Request url\n   * @param {QueryParamsOrBody} data - Query Params in case of GET and HEAD requests, body payload otherwise\n   * @param {RequestConfig} config - Request config passed when making the request\n   * @returns {RequestConfig} - Provider's instance\n   */\n  protected buildConfig(\n    url: string,\n    data: QueryParamsOrBody,\n    config: RequestConfig,\n  ): RequestConfig {\n    const method = (config.method || this.method).toUpperCase() as Method;\n    const isGetAlikeMethod = method === 'GET' || method === 'HEAD';\n\n    const dynamicUrl = replaceUrlPathParams(\n      url,\n      config.urlPathParams || this.config.urlPathParams,\n    );\n\n    // The explicitly passed \"params\"\n    const explicitParams = config.params || this.config.params;\n\n    // The explicitly passed \"body\" or \"data\"\n    const explicitBodyData =\n      config.body || config.data || this.config.body || this.config.data;\n\n    // For convenience, in POST requests the body payload is the \"data\"\n    // In edge cases we want to use Query Params in the POST requests\n    // and use explicitly passed \"body\" or \"data\" from request config\n    const shouldTreatDataAsParams =\n      data && (isGetAlikeMethod || explicitBodyData) ? true : false;\n\n    // Final body data\n    let body: RequestConfig['data'];\n\n    // Only applicable for request methods 'PUT', 'POST', 'DELETE', and 'PATCH'\n    if (!isGetAlikeMethod) {\n      body = explicitBodyData || (data as BodyPayload);\n    }\n\n    if (this.isCustomFetcher()) {\n      return {\n        ...config,\n        method,\n        url: dynamicUrl,\n        params: shouldTreatDataAsParams\n          ? (data as QueryParams)\n          : explicitParams,\n        data: body,\n      };\n    }\n\n    // Native fetch\n    const credentials =\n      config.withCredentials || this.config.withCredentials\n        ? 'include'\n        : config.credentials;\n\n    delete config.data;\n    delete config.withCredentials;\n\n    const urlPath =\n      explicitParams || shouldTreatDataAsParams\n        ? appendQueryParams(dynamicUrl, explicitParams || (data as QueryParams))\n        : dynamicUrl;\n    const isFullUrl = urlPath.includes('://');\n    const baseURL = isFullUrl ? '' : config.baseURL || this.baseURL;\n\n    // Automatically stringify request body, if possible and when not dealing with strings\n    if (\n      body &&\n      typeof body !== 'string' &&\n      !(body instanceof URLSearchParams) &&\n      isJSONSerializable(body)\n    ) {\n      body = JSON.stringify(body);\n    }\n\n    return {\n      ...config,\n      credentials,\n      body,\n      method,\n\n      url: baseURL + urlPath,\n\n      // Add sensible defaults\n      headers: {\n        Accept: APPLICATION_JSON + ', text/plain, */*',\n        'Content-Type': APPLICATION_JSON + ';charset=utf-8',\n        ...(config.headers || this.config.headers || {}),\n      },\n    };\n  }\n\n  /**\n   * Process global Request Error\n   *\n   * @param {ResponseError} error      Error instance\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {void}\n   */\n  protected processError(\n    error: ResponseError,\n    requestConfig: RequestConfig,\n  ): void {\n    if (this.isRequestCancelled(error)) {\n      return;\n    }\n\n    if (this.logger?.warn) {\n      this.logger.warn('API ERROR', error);\n    }\n\n    // Invoke per request \"onError\" interceptor\n    if (requestConfig.onError) {\n      requestConfig.onError(error);\n    }\n\n    // Invoke global \"onError\" interceptor\n    if (this.config.onError) {\n      this.config.onError(error);\n    }\n  }\n\n  /**\n   * Output default response in case of an error, depending on chosen strategy\n   *\n   * @param {ResponseError} error      Error instance\n   * @param {FetchResponse} response      Response\n   * @param {RequestConfig} requestConfig   Per endpoint request config\n   * @returns {*} Error response\n   */\n  protected async outputErrorResponse(\n    error: ResponseError,\n    response: FetchResponse,\n    requestConfig: RequestConfig,\n  ): Promise<any> {\n    const isRequestCancelled = this.isRequestCancelled(error);\n    const errorHandlingStrategy = requestConfig.strategy || this.strategy;\n    const rejectCancelled =\n      typeof requestConfig.rejectCancelled !== 'undefined'\n        ? requestConfig.rejectCancelled\n        : this.config.rejectCancelled;\n\n    // By default cancelled requests aren't rejected (softFail strategy)\n    if (!(isRequestCancelled && !rejectCancelled)) {\n      // Hang the promise\n      if (errorHandlingStrategy === 'silent') {\n        await new Promise(() => null);\n      }\n      // Reject the promise\n      else if (errorHandlingStrategy === 'reject') {\n        return Promise.reject(error);\n      }\n    }\n\n    return this.outputResponse(response, requestConfig, error);\n  }\n\n  /**\n   * Output error response depending on chosen strategy\n   *\n   * @param {ResponseError} error               Error instance\n   * @returns {boolean}                        True if request is aborted\n   */\n  public isRequestCancelled(error: ResponseError): boolean {\n    return error.name === 'AbortError' || error.name === 'CanceledError';\n  }\n\n  /**\n   * Detects if a custom fetcher is utilized\n   *\n   * @returns {boolean}                        True if it's a custom fetcher\n   */\n  protected isCustomFetcher(): boolean {\n    return this.fetcher !== null;\n  }\n\n  /**\n   * Handle Request depending on used strategy\n   *\n   * @param {string} url - Request url\n   * @param {QueryParamsOrBody} data - Query Params in case of GET and HEAD requests, body payload otherwise\n   * @param {RequestConfig} config - Request config\n   * @throws {ResponseError}\n   * @returns {Promise<ResponseData & FetchResponse<ResponseData>>} Response Data\n   */\n  public async request<ResponseData = APIResponse>(\n    url: string,\n    data: QueryParamsOrBody = null,\n    config: RequestConfig = null,\n  ): Promise<ResponseData & FetchResponse<ResponseData>> {\n    let response: FetchResponse<ResponseData> = null;\n    const _config = config || {};\n    const _requestConfig = this.buildConfig(url, data, _config);\n\n    const timeout =\n      typeof _requestConfig.timeout !== 'undefined'\n        ? _requestConfig.timeout\n        : this.timeout;\n    const isCancellable =\n      typeof _requestConfig.cancellable !== 'undefined'\n        ? _requestConfig.cancellable\n        : this.config.cancellable;\n    const dedupeTime =\n      typeof _requestConfig.dedupeTime !== 'undefined'\n        ? _requestConfig.dedupeTime\n        : this.config.dedupeTime;\n\n    const {\n      retries,\n      delay,\n      backoff,\n      retryOn,\n      shouldRetry,\n      maxDelay,\n      resetTimeout,\n    } = {\n      ...this.retry,\n      ...(_requestConfig?.retry || {}),\n    };\n\n    let attempt = 0;\n    let waitTime = delay;\n\n    while (attempt <= retries) {\n      try {\n        // Add the request to the queue. Make sure to handle deduplication, cancellation, timeouts in accordance to retry settings\n        const controller = await addRequest(\n          _requestConfig,\n          timeout,\n          dedupeTime,\n          isCancellable,\n          resetTimeout,\n        );\n        const signal = controller.signal;\n\n        let requestConfig: RequestConfig = {\n          signal,\n          ..._requestConfig,\n        };\n\n        // Local interceptors\n        requestConfig = await interceptRequest(\n          requestConfig,\n          requestConfig?.onRequest,\n        );\n\n        // Global interceptors\n        requestConfig = await interceptRequest(\n          requestConfig,\n          this.config?.onRequest,\n        );\n\n        if (this.isCustomFetcher()) {\n          response = (await (this.requestInstance as any).request(\n            requestConfig,\n          )) as FetchResponse<ResponseData>;\n        } else {\n          response = (await globalThis.fetch(\n            requestConfig.url,\n            requestConfig as RequestInit,\n          )) as FetchResponse<ResponseData>;\n\n          // Add more information to response object\n          response.config = requestConfig;\n          response.data = await this.parseData(response);\n\n          // Check if the response status is not outside the range 200-299 and if so, output error\n          if (!response.ok) {\n            throw new ResponseErr(\n              `${requestConfig.url} failed! Status: ${response.status || null}`,\n              requestConfig,\n              response,\n            );\n          }\n        }\n\n        // Local interceptors\n        response = await interceptResponse(response, requestConfig?.onResponse);\n\n        // Global interceptors\n        response = await interceptResponse(response, this.config?.onResponse);\n\n        return this.outputResponse(response, requestConfig) as ResponseData &\n          FetchResponse<ResponseData>;\n      } catch (error) {\n        if (\n          attempt === retries ||\n          !(await shouldRetry(error, attempt)) ||\n          !retryOn?.includes(error?.response?.status || error?.status)\n        ) {\n          this.processError(error, _requestConfig);\n\n          removeRequest(_requestConfig);\n\n          return this.outputErrorResponse(error, response, _requestConfig);\n        }\n\n        if (this.logger?.warn) {\n          this.logger.warn(\n            `Attempt ${attempt + 1} failed. Retrying in ${waitTime}ms...`,\n          );\n        }\n\n        await delayInvocation(waitTime);\n\n        waitTime *= backoff;\n        waitTime = Math.min(waitTime, maxDelay);\n        attempt++;\n      }\n    }\n\n    return this.outputResponse(response, _requestConfig) as ResponseData &\n      FetchResponse<ResponseData>;\n  }\n\n  /**\n   * Parses the response data based on the Content-Type header.\n   *\n   * @param response - The Response object to parse.\n   * @returns A Promise that resolves to the parsed data.\n   */\n  public async parseData<ResponseData = APIResponse>(\n    response: FetchResponse<ResponseData>,\n  ): Promise<any> {\n    // Bail early when body is empty\n    if (!response?.body) {\n      return null;\n    }\n\n    const contentType = String(\n      (response as Response).headers?.get('Content-Type') || '',\n    ).split(';')[0]; // Correctly handle charset\n\n    let data;\n\n    try {\n      if (\n        contentType.includes(APPLICATION_JSON) ||\n        contentType.includes('+json')\n      ) {\n        data = await response.json(); // Parse JSON response\n      } else if (contentType.includes('multipart/form-data')) {\n        data = await response.formData(); // Parse as FormData\n      } else if (contentType.includes('application/octet-stream')) {\n        data = await response.blob(); // Parse as blob\n      } else if (contentType.includes('application/x-www-form-urlencoded')) {\n        data = await response.formData(); // Handle URL-encoded forms\n      } else if (contentType.includes('text/')) {\n        data = await response.text(); // Parse as text\n      } else {\n        try {\n          const responseClone = response.clone();\n\n          // Handle edge case of no content type being provided... We assume JSON here.\n          data = await responseClone.json();\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        } catch (_e) {\n          // Handle streams\n          data = await response.text();\n        }\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (_error) {\n      // Parsing failed, fallback to null\n      data = null;\n    }\n\n    return data;\n  }\n\n  public processHeaders<ResponseData>(\n    response: FetchResponse<ResponseData>,\n  ): HeadersObject {\n    const headers = response.headers;\n\n    if (!headers) {\n      return {};\n    }\n\n    const headersObject: HeadersObject = {};\n\n    // Handle Headers object with entries() method\n    if (headers instanceof Headers) {\n      headers.forEach((value, key) => {\n        headersObject[key] = value;\n      });\n    } else if (typeof headers === 'object' && headers !== null) {\n      // Handle plain object\n      for (const [key, value] of Object.entries(headers)) {\n        // Normalize keys to lowercase as per RFC 2616 4.2\n        // https://datatracker.ietf.org/doc/html/rfc2616#section-4.2\n        headersObject[key.toLowerCase()] = value;\n      }\n    }\n\n    return headersObject;\n  }\n\n  /**\n   * Recursively flattens the data object if it meets specific criteria.\n   *\n   * The method checks if the provided `data` is an object with exactly one property named `data`.\n   * If so, it recursively flattens the `data` property. Otherwise, it returns the `data` as-is.\n   *\n   * @param {any} data - The data to be flattened. Can be of any type, including objects, arrays, or primitives.\n   * @returns {any} - The flattened data if the criteria are met; otherwise, the original `data`.\n   */\n  protected flattenData(data: any): any {\n    if (\n      data &&\n      typeof data === 'object' &&\n      typeof data.data !== 'undefined' &&\n      Object.keys(data).length === 1\n    ) {\n      return this.flattenData(data.data);\n    }\n\n    return data;\n  }\n\n  /**\n   * Output response\n   *\n   * @param response - Response payload\n   * @param {RequestConfig} requestConfig - Request config\n   * @param error - whether the response is erroneous\n   * @returns {ResponseData | FetchResponse<ResponseData>} Response data\n   */\n  protected outputResponse<ResponseData = APIResponse>(\n    response: FetchResponse<ResponseData>,\n    requestConfig: RequestConfig,\n    error = null,\n  ): ResponseData | FetchResponse<ResponseData> {\n    const defaultResponse =\n      typeof requestConfig.defaultResponse !== 'undefined'\n        ? requestConfig.defaultResponse\n        : this.defaultResponse;\n    const flattenResponse =\n      typeof requestConfig.flattenResponse !== 'undefined'\n        ? requestConfig.flattenResponse\n        : this.flattenResponse;\n\n    if (!response) {\n      return flattenResponse\n        ? defaultResponse\n        : {\n            error,\n            headers: null,\n            data: defaultResponse,\n            config: requestConfig,\n          };\n    }\n\n    // Clean up the error object\n    if (error !== null) {\n      delete error?.response;\n      delete error?.request;\n      delete error?.config;\n    }\n\n    let data = response?.data;\n\n    // Set the default response if the provided data is an empty object\n    if (\n      data === undefined ||\n      data === null ||\n      (typeof data === 'object' && Object.keys(data).length === 0)\n    ) {\n      data = defaultResponse;\n    }\n\n    // Return flattened response immediately\n    if (flattenResponse) {\n      return this.flattenData(data);\n    }\n\n    const isCustomFetcher = this.isCustomFetcher();\n\n    if (isCustomFetcher) {\n      return response;\n    }\n\n    return {\n      // Native fetch()\n      body: response.body,\n      blob: response.blob,\n      json: response.json,\n      text: response.text,\n      clone: response.clone,\n      bodyUsed: response.bodyUsed,\n      arrayBuffer: response.arrayBuffer,\n      formData: response.formData,\n      ok: response.ok,\n      redirected: response.redirected,\n      type: response.type,\n      url: response.url,\n      status: response.status,\n      statusText: response.statusText,\n\n      // Extend with extra information\n      error,\n      data,\n      headers: this.processHeaders(response),\n      config: requestConfig,\n    };\n  }\n}\n","import { RequestHandler } from './request-handler';\nimport type {\n  FetcherInstance,\n  RequestConfig,\n  FetchResponse,\n} from './types/request-handler';\nimport type {\n  ApiHandlerConfig,\n  ApiHandlerMethods,\n  ApiHandlerReturnType,\n  APIResponse,\n  QueryParamsOrBody,\n  UrlPathParams,\n} from './types/api-handler';\n\n/**\n * Creates an instance of API Handler.\n * It creates an API fetcher function using native fetch() or a custom fetcher if it is passed as \"fetcher\".\n *\n * @param {Object} config - Configuration object for the API fetcher.\n * @param {string} config.apiUrl - The base URL for the API.\n * @param {Object} config.endpoints - An object containing endpoint definitions.\n * @param {number} config.timeout - You can set the timeout for particular request in milliseconds.\n * @param {number} config.cancellable - If true, the previous requests will be automatically cancelled.\n * @param {number} config.rejectCancelled - If true and request is set to cancellable, a cancelled request promise will be rejected. By default, instead of rejecting the promise, defaultResponse is returned.\n * @param {number} config.timeout - Request timeout\n * @param {string} config.strategy - Error Handling Strategy\n * @param {string} config.flattenResponse - Whether to flatten response \"data\" object within \"data\" one\n * @param {*} config.defaultResponse - Default response when there is no data or when endpoint fails depending on the chosen strategy. It's \"null\" by default\n * @param {Object} [config.retry] - Options for retrying requests.\n * @param {number} [config.retry.retries=0] - Number of retry attempts. No retries by default.\n * @param {number} [config.retry.delay=1000] - Initial delay between retries in milliseconds.\n * @param {number} [config.retry.backoff=1.5] - Exponential backoff factor.\n * @param {number[]} [config.retry.retryOn=[502, 504, 408]] - HTTP status codes to retry on.\n * @param {RequestInterceptor|RequestInterceptor[]} [config.onRequest] - Optional request interceptor function or an array of functions.\n * These functions will be called with the request configuration object before the request is made. Can be used to modify or log the request configuration.\n * @param {ResponseInterceptor|ResponseInterceptor[]} [config.onResponse] - Optional response interceptor function or an array of functions.\n * These functions will be called with the response object after the response is received. an be used to modify or log the response data.\n * @param {Function} [config.onError] - Optional callback function for handling errors.\n * @param {Object} [config.headers] - Optional default headers to include in every request.\n * @param {Object} config.fetcher - The Custom Fetcher instance to use for making requests. It should expose create() and request() functions.\n * @param {*} config.logger - Instance of custom logger. Either class or an object similar to \"console\". Console is used by default.\n * @returns API handler functions and endpoints to call\n *\n * @example\n * // Define endpoint paths\n * const endpoints = {\n *   getUser: '/user',\n *   createPost: '/post',\n * };\n *\n * // Create the API fetcher with configuration\n * const api = createApiFetcher({\n *   endpoints,\n *   apiUrl: 'https://example.com/api',\n *   onError(error) {\n *     console.log('Request failed', error);\n *   },\n *   headers: {\n *     'my-auth-key': 'example-auth-key-32rjjfa',\n *   },\n * });\n *\n * // Fetch user data\n * const response = await api.getUser({ userId: 1, ratings: [1, 2] })\n */\nfunction createApiFetcher<\n  EndpointsMethods extends object,\n  EndpointsCfg = never,\n>(config: ApiHandlerConfig<EndpointsMethods>) {\n  const endpoints = config.endpoints;\n  const requestHandler = new RequestHandler(config);\n\n  /**\n   * Get Fetcher Provider Instance\n   *\n   * @returns {FetcherInstance} Request Handler's Fetcher instance\n   */\n  function getInstance(): FetcherInstance {\n    return requestHandler.getInstance();\n  }\n\n  /**\n   * Triggered when trying to use non-existent endpoints\n   *\n   * @param endpointName Endpoint Name\n   * @returns {Promise}\n   */\n  function handleNonImplemented(endpointName: string): Promise<null> {\n    console.error(`${endpointName} endpoint must be added to 'endpoints'.`);\n\n    return Promise.resolve(null);\n  }\n\n  /**\n   * Handle Single API Request\n   * It considers settings in following order: per-request settings, global per-endpoint settings, global settings.\n   *\n   * @param {string} endpointName - The name of the API endpoint to call.\n   * @param {QueryParamsOrBody} [data={}] - Query parameters to include in the request.\n   * @param {UrlPathParams} [urlPathParams={}] - URI parameters to include in the request.\n   * @param {EndpointConfig} [requestConfig={}] - Additional configuration for the request.\n   * @returns {Promise<Response & FetchResponse>} - A promise that resolves with the response from the API provider.\n   */\n  async function request<Response = APIResponse>(\n    endpointName: keyof EndpointsMethods | string,\n    data: QueryParamsOrBody = {},\n    urlPathParams: UrlPathParams = {},\n    requestConfig: RequestConfig = {},\n  ): Promise<Response & FetchResponse<Response>> {\n    // Use global per-endpoint settings\n    const endpointConfig = endpoints[endpointName as string];\n    const endpointSettings = { ...endpointConfig };\n\n    const responseData = await requestHandler.request<Response>(\n      endpointSettings.url,\n      data,\n      {\n        ...endpointSettings,\n        ...requestConfig,\n        urlPathParams,\n      },\n    );\n\n    return responseData;\n  }\n\n  /**\n   * Maps all API requests using native Proxy\n   *\n   * @param {*} prop          Caller\n   */\n  function get(prop: string | symbol) {\n    if (prop in apiHandler) {\n      return apiHandler[prop];\n    }\n\n    // Prevent handler from triggering non-existent endpoints\n    if (!endpoints[prop as string]) {\n      return handleNonImplemented.bind(null, prop);\n    }\n\n    return apiHandler.request.bind(null, prop);\n  }\n\n  const apiHandler: ApiHandlerMethods<EndpointsMethods> = {\n    config,\n    endpoints,\n    requestHandler,\n    getInstance,\n    request,\n  };\n\n  return new Proxy(apiHandler, {\n    get: (_target, prop) => get(prop),\n  }) as ApiHandlerReturnType<EndpointsMethods, EndpointsCfg>;\n}\n\nexport { createApiFetcher };\n"],"mappings":"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","names":["src_exports","__export","createApiFetcher","fetchf","__toCommonJS","interceptRequest","config","interceptors","interceptorList","interceptedConfig","interceptor","interceptResponse","response","interceptedResponse","ResponseErr","message","requestInfo","response","appendQueryParams","url","params","encodedQueryString","add","k","v","buildParams","prefix","obj","i","len","key","replaceUrlPathParams","urlPathParams","str","word","isJSONSerializable","value","t","proto","delayInvocation","ms","resolve","queue","locks","withLock","key","fn","release","lock","resolve","addRequest","config","timeout","dedupeTime","isCancellable","resetTimeout","now","existingItem","removeRequest","controller","timeoutId","error","item","APPLICATION_JSON","RequestHandler","fetcher","timeout","strategy","flattenResponse","defaultResponse","logger","config","url","data","method","isGetAlikeMethod","dynamicUrl","replaceUrlPathParams","explicitParams","explicitBodyData","shouldTreatDataAsParams","body","credentials","urlPath","appendQueryParams","baseURL","isJSONSerializable","error","requestConfig","_a","response","isRequestCancelled","errorHandlingStrategy","rejectCancelled","_b","_c","_d","_config","_requestConfig","isCancellable","dedupeTime","retries","delay","backoff","retryOn","shouldRetry","maxDelay","resetTimeout","attempt","waitTime","addRequest","interceptRequest","ResponseErr","interceptResponse","removeRequest","delayInvocation","contentType","headers","headersObject","value","key","createApiFetcher","config","endpoints","requestHandler","RequestHandler","getInstance","handleNonImplemented","endpointName","request","data","urlPathParams","requestConfig","endpointSettings","get","prop","apiHandler","_target","fetchf","url","config","RequestHandler"]}