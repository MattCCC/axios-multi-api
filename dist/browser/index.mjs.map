{"version":3,"sources":["../../src/interceptor-manager.ts","../../src/response-error.ts","../../src/constants.ts","../../src/utils.ts","../../src/queue-manager.ts","../../src/response-parser.ts","../../src/hash.ts","../../src/cache-manager.ts","../../src/request-handler.ts","../../src/api-handler.ts","../../src/index.ts"],"sourcesContent":["type InterceptorFunction<T> = (object: T) => Promise<T>;\n\n/**\n * Applies interceptors to the object. Interceptors can be a single function or an array of functions.\n *\n * @template T - Type of the object.\n * @template I - Type of interceptors.\n *\n * @param {T} object - The object to process.\n * @param {InterceptorFunction<T> | InterceptorFunction<T>[]} [interceptors] - Interceptor function(s).\n *\n * @returns {Promise<void>} - Nothing as the function is non-idempotent.\n */\nexport async function applyInterceptor<\n  T extends object,\n  I = InterceptorFunction<T> | InterceptorFunction<T>[],\n>(object: T, interceptors?: I): Promise<void> {\n  if (!interceptors) {\n    return;\n  }\n\n  if (typeof interceptors === 'function') {\n    const value = await interceptors(object);\n\n    if (value) {\n      Object.assign(object, value);\n    }\n  } else if (Array.isArray(interceptors)) {\n    for (const interceptor of interceptors) {\n      const value = await interceptor(object);\n\n      if (value) {\n        Object.assign(object, value);\n      }\n    }\n  }\n}\n","import type { FetchResponse, RequestConfig } from './types';\n\nexport class ResponseErr extends Error {\n  response: FetchResponse;\n  request: RequestConfig;\n  config: RequestConfig;\n  status: number;\n  statusText: string;\n\n  constructor(\n    message: string,\n    requestInfo: RequestConfig,\n    response: FetchResponse,\n  ) {\n    super(message);\n\n    this.name = 'ResponseError';\n    this.message = message;\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.request = requestInfo;\n    this.config = requestInfo;\n    this.response = response;\n  }\n}\n","export const APPLICATION_CONTENT_TYPE = 'application/';\n\nexport const APPLICATION_JSON = APPLICATION_CONTENT_TYPE + 'json';\nexport const CONTENT_TYPE = 'Content-Type';\n\nexport const UNDEFINED = 'undefined';\nexport const OBJECT = 'object';\nexport const STRING = 'string';\n\nexport const ABORT_ERROR = 'AbortError';\nexport const TIMEOUT_ERROR = 'TimeoutError';\nexport const CANCELLED_ERROR = 'CanceledError';\n\nexport const GET = 'GET';\nexport const HEAD = 'HEAD';\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { OBJECT, STRING, UNDEFINED } from './constants';\nimport type {\n  DefaultUrlParams,\n  HeadersObject,\n  QueryParams,\n  UrlPathParams,\n} from './types';\n\nexport function isSearchParams(data: unknown): boolean {\n  return data instanceof URLSearchParams;\n}\n\n/**\n * Determines if a value is a non-null object.\n *\n * @param {any} value - The value to check.\n * @returns {boolean} - True if the value is a non-null object.\n */\nexport function isObject(value: any): value is Record<string, any> {\n  return value !== null && typeof value === OBJECT;\n}\n\n/**\n * Shallowly serializes an object by converting its key-value pairs into a string representation.\n * This function does not recursively serialize nested objects.\n *\n * @param obj - The object to serialize.\n * @returns A string representation of the object's top-level properties.\n */\nexport function shallowSerialize(obj: Record<string, any>): string {\n  let result = '';\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result += key + ':' + obj[key];\n    }\n  }\n\n  return result;\n}\n\n/**\n * Sorts the keys of an object and returns a new object with sorted keys.\n *\n * This function is optimized for performance by minimizing the number of object operations\n * and using a single pass to create the sorted object.\n *\n * @param {Object} obj - The object to be sorted by keys.\n * @returns {Object} - A new object with keys sorted in ascending order.\n */\nexport function sortObject(obj: Record<string, any>): object {\n  const sortedObj = {} as Record<string, string>;\n  const keys = Object.keys(obj);\n\n  keys.sort();\n\n  for (let i = 0, len = keys.length; i < len; i++) {\n    const key = keys[i];\n    sortedObj[key] = obj[key];\n  }\n\n  return sortedObj;\n}\n\n/**\n * Appends a query string to a URL, ensuring proper handling of existing query parameters.\n *\n * @param baseUrl - The base URL to which the query string will be appended.\n * @param queryString - The encoded query string to append.\n * @returns The URL with the appended query string, or the original URL if no query string is provided.\n */\nfunction appendQueryStringToUrl(baseUrl: string, queryString: string): string {\n  if (!queryString) {\n    return baseUrl;\n  }\n\n  return baseUrl.includes('?')\n    ? `${baseUrl}&${queryString}`\n    : `${baseUrl}?${queryString}`;\n}\n\n/**\n * Appends query parameters to a given URL.\n *\n * @param {string} url - The base URL to which query parameters will be appended.\n * @param {QueryParams} params - An object containing the query parameters to append.\n * @returns {string} - The URL with the appended query parameters.\n */\nexport function appendQueryParams(url: string, params: QueryParams): string {\n  if (!params) {\n    return url;\n  }\n\n  // Check if `params` is an instance of URLSearchParams and bail early if it is\n  if (isSearchParams(params)) {\n    const encodedQueryString = params.toString();\n\n    return appendQueryStringToUrl(url, encodedQueryString);\n  }\n\n  // This is exact copy of what JQ used to do. It works much better than URLSearchParams\n  const s: string[] = [];\n  const encode = encodeURIComponent;\n  const add = (k: string, v: any) => {\n    v = typeof v === 'function' ? v() : v;\n    v = v === null ? '' : v === undefined ? '' : v;\n    s[s.length] = encode(k) + '=' + encode(v);\n  };\n\n  const buildParams = (prefix: string, obj: any) => {\n    let i: number, len: number, key: string;\n\n    if (prefix) {\n      if (Array.isArray(obj)) {\n        for (i = 0, len = obj.length; i < len; i++) {\n          buildParams(\n            prefix + '[' + (typeof obj[i] === OBJECT && obj[i] ? i : '') + ']',\n            obj[i],\n          );\n        }\n      } else if (typeof obj === OBJECT && obj !== null) {\n        for (key in obj) {\n          buildParams(prefix + '[' + key + ']', obj[key]);\n        }\n      } else {\n        add(prefix, obj);\n      }\n    } else if (Array.isArray(obj)) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        add(obj[i].name, obj[i].value);\n      }\n    } else {\n      for (key in obj) {\n        buildParams(key, obj[key]);\n      }\n    }\n    return s;\n  };\n\n  const queryStringParts = buildParams('', params).join('&');\n\n  // Encode special characters as per RFC 3986, https://datatracker.ietf.org/doc/html/rfc3986\n  const encodedQueryString = queryStringParts.replace(/%5B%5D/g, '[]'); // Keep '[]' for arrays\n\n  return appendQueryStringToUrl(url, encodedQueryString);\n}\n\n/**\n * Replaces dynamic URI parameters in a URL string with values from the provided `urlPathParams` object.\n * Parameters in the URL are denoted by `:<paramName>`, where `<paramName>` is a key in `urlPathParams`.\n *\n * @param {string} url - The URL string containing placeholders in the format `:<paramName>`.\n * @param {Object} urlPathParams - An object containing the parameter values to replace placeholders.\n * @param {string} urlPathParams.paramName - The value to replace the placeholder `:<paramName>` in the URL.\n * @returns {string} - The URL string with placeholders replaced by corresponding values from `urlPathParams`.\n */\nexport function replaceUrlPathParams(\n  url: string,\n  urlPathParams: UrlPathParams,\n): string {\n  if (!urlPathParams) {\n    return url;\n  }\n\n  return url.replace(/:\\w+/g, (str): string => {\n    const word = str.substring(1);\n\n    if ((urlPathParams as DefaultUrlParams)[word]) {\n      return String((urlPathParams as DefaultUrlParams)[word]);\n    }\n\n    return str;\n  });\n}\n\n/**\n * Checks if a value is JSON serializable.\n *\n * JSON serializable values include:\n * - Primitive types: string, number, boolean, null\n * - Arrays\n * - Plain objects (i.e., objects without special methods)\n * - Values with a `toJSON` method\n *\n * @param {any} value - The value to check for JSON serializability.\n * @returns {boolean} - Returns `true` if the value is JSON serializable, otherwise `false`.\n */\nexport function isJSONSerializable(value: any): boolean {\n  const t = typeof value;\n\n  if (t === UNDEFINED || value === null) {\n    return false;\n  }\n\n  if (t === STRING || t === 'number' || t === 'boolean') {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return true;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return false;\n  }\n\n  if (value instanceof Date) {\n    return false;\n  }\n\n  if (t === OBJECT) {\n    const proto = Object.getPrototypeOf(value);\n\n    // Check if the prototype is `Object.prototype` or `null` (plain object)\n    if (proto === Object.prototype || proto === null) {\n      return true;\n    }\n\n    // Check if the object has a toJSON method\n    if (typeof value.toJSON === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport async function delayInvocation(ms: number): Promise<boolean> {\n  return new Promise((resolve) =>\n    setTimeout(() => {\n      return resolve(true);\n    }, ms),\n  );\n}\n\n/**\n * Recursively flattens the data object if it meets specific criteria.\n *\n * The method checks if the provided `data` is an object with exactly one property named `data`.\n * If so, it recursively flattens the `data` property. Otherwise, it returns the `data` as-is.\n *\n * @param {any} data - The data to be flattened. Can be of any type, including objects, arrays, or primitives.\n * @returns {any} - The flattened data if the criteria are met; otherwise, the original `data`.\n */\nexport function flattenData(data: any): any {\n  if (\n    data &&\n    typeof data === OBJECT &&\n    typeof data.data !== UNDEFINED &&\n    Object.keys(data).length === 1\n  ) {\n    return flattenData(data.data);\n  }\n\n  return data;\n}\n\n/**\n * Processes headers and returns them as a normalized object.\n *\n * Handles both `Headers` instances and plain objects. Normalizes header keys to lowercase\n * as per RFC 2616 section 4.2.\n *\n * @param headers - The headers to process. Can be an instance of `Headers`, a plain object,\n *                   or `null`. If `null`, an empty object is returned.\n * @returns {HeadersObject} - A normalized headers object with lowercase keys.\n */\nexport function processHeaders(\n  headers?: (HeadersObject & HeadersInit) | null | Headers,\n): HeadersObject {\n  if (!headers) {\n    return {};\n  }\n\n  const headersObject: HeadersObject = {};\n\n  // Handle Headers object with entries() method\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      headersObject[key] = value;\n    });\n  } else if (typeof headers === OBJECT && headers !== null) {\n    // Handle plain object\n    for (const [key, value] of Object.entries(headers)) {\n      // Normalize keys to lowercase as per RFC 2616 4.2\n      // https://datatracker.ietf.org/doc/html/rfc2616#section-4.2\n      headersObject[key.toLowerCase()] = value;\n    }\n  }\n\n  return headersObject;\n}\n\n/**\n * Deletes a property from an object if it exists.\n *\n * @param obj - The object from which to delete the property.\n * @param property - The property to delete from the object.\n */\nexport function deleteProperty<T extends Record<string, any>>(\n  obj: T | null,\n  property: keyof T,\n): void {\n  if (obj && property in obj) {\n    delete obj[property];\n  }\n}\n","import { ABORT_ERROR, TIMEOUT_ERROR } from './constants';\nimport type { RequestConfig } from './types';\nimport type { QueueItem, RequestsQueue } from './types/queue-manager';\n\n/**\n * Queue Manager is responsible for managing and controlling the flow of concurrent or sequential requests. It handles:\n * - Request Queueing and Deduplication\n * - Request Timeout Handling\n * - Abort Controller Management and Request Cancellation\n * - Concurrency Control and Locking\n * - Request Lifecycle Management\n */\nconst queue: RequestsQueue = new Map<RequestConfig, QueueItem>();\n\n/**\n * Adds a request to the queue if it's not already being processed within the dedupeTime interval.\n *\n * @param {RequestConfig} config - The request configuration object.\n * @param {number} timeout - Timeout in milliseconds for the request.\n * @param {number} dedupeTime - Deduplication time in milliseconds.\n * @param {boolean} isCancellable - If true, then the previous request with same configuration should be aborted.\n * @param {boolean} isTimeoutEnabled - Whether timeout is enabled.\n * @returns {Promise<AbortController>} - A promise that resolves to an AbortController.\n */\nexport async function addRequest(\n  config: RequestConfig,\n  timeout: number | undefined,\n  dedupeTime: number = 0,\n  isCancellable: boolean = false,\n  isTimeoutEnabled: boolean = true,\n): Promise<AbortController> {\n  const now = Date.now();\n  const item = queue.get(config);\n\n  if (item) {\n    const isCancellable = item[3];\n    const previousController = item[0];\n    const timeoutId = item[1];\n\n    // If the request is already in the queue and within the dedupeTime, reuse the existing controller\n    if (!isCancellable && now - item[2] < dedupeTime) {\n      return previousController;\n    }\n\n    // If the request is too old, remove it and proceed to add a new one\n    // Abort previous request, if applicable, and continue as usual\n    if (isCancellable) {\n      previousController.abort(\n        new DOMException('Aborted due to new request', ABORT_ERROR),\n      );\n    }\n\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    queue.delete(config);\n  }\n\n  const controller = new AbortController();\n\n  const timeoutId = isTimeoutEnabled\n    ? setTimeout(() => {\n        const error = new DOMException(\n          `${config.url} aborted due to timeout`,\n          TIMEOUT_ERROR,\n        );\n\n        removeRequest(config, error);\n      }, timeout)\n    : null;\n\n  queue.set(config, [controller, timeoutId, now, isCancellable]);\n\n  return controller;\n}\n\n/**\n * Removes a request from the queue and clears its timeout.\n *\n * @param config - The request configuration.\n * @param {boolean} error - Error payload so to force the request to abort.\n */\nexport async function removeRequest(\n  config: RequestConfig,\n  error: DOMException | null | string = null,\n): Promise<void> {\n  const item = queue.get(config);\n\n  if (item) {\n    const controller = item[0];\n    const timeoutId = item[1];\n\n    // If the request is not yet aborted, abort it with the provided error\n    if (error && !controller.signal.aborted) {\n      controller.abort(error);\n    }\n\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    queue.delete(config);\n  }\n}\n\n/**\n * Gets the AbortController for a request configuration.\n *\n * @param config - The request configuration.\n * @returns {AbortController | undefined} - The AbortController or undefined.\n */\nexport async function getController(\n  config: RequestConfig,\n): Promise<AbortController | undefined> {\n  const item = queue.get(config);\n\n  return item?.[0];\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  APPLICATION_CONTENT_TYPE,\n  APPLICATION_JSON,\n  CONTENT_TYPE,\n} from './constants';\nimport type { DefaultResponse, FetchResponse } from './types/request-handler';\n\n/**\n * Parses the response data based on the Content-Type header.\n *\n * @param response - The Response object to parse.\n * @returns A Promise that resolves to the parsed data.\n */\nexport async function parseResponseData<ResponseData = DefaultResponse>(\n  response: FetchResponse<ResponseData>,\n): Promise<any> {\n  // Bail early when body is empty\n  if (!response?.body) {\n    return null;\n  }\n\n  const contentType = String(\n    (response as Response).headers?.get(CONTENT_TYPE) || '',\n  ).split(';')[0]; // Correctly handle charset\n\n  let data;\n\n  try {\n    if (\n      contentType.includes(APPLICATION_JSON) ||\n      contentType.includes('+json')\n    ) {\n      data = await response.json(); // Parse JSON response\n    } else if (contentType.includes('multipart/form-data')) {\n      data = await response.formData(); // Parse as FormData\n    } else if (\n      contentType.includes(APPLICATION_CONTENT_TYPE + 'octet-stream')\n    ) {\n      data = await response.blob(); // Parse as blob\n    } else if (\n      contentType.includes(APPLICATION_CONTENT_TYPE + 'x-www-form-urlencoded')\n    ) {\n      data = await response.formData(); // Handle URL-encoded forms\n    } else if (contentType.includes('text/')) {\n      data = await response.text(); // Parse as text\n    } else {\n      try {\n        const responseClone = response.clone();\n\n        // Handle edge case of no content type being provided... We assume JSON here.\n        data = await responseClone.json();\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (_e) {\n        // Handle streams\n        data = await response.text();\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  } catch (_error) {\n    // Parsing failed, fallback to null\n    data = null;\n  }\n\n  return data;\n}\n","const PRIME_MULTIPLIER = 31;\n\n/**\n * Computes a hash value for a given string using the variant of djb2 hash function.\n * This hash function is non-cryptographic and designed for speed.\n * @author Daniel J. Bernstein (of djb2)\n *\n * @param str Input string to hash\n * @returns {string} Hash\n */\nexport function hash(str: string): string {\n  let hash = 0;\n\n  for (let i = 0, len = str.length; i < len; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash * PRIME_MULTIPLIER + char) | 0;\n  }\n\n  return String(hash);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { hash } from './hash';\nimport { fetchf } from './index';\nimport type { FetcherConfig } from './types/request-handler';\nimport type { CacheEntry } from './types/cache-manager';\nimport { GET, OBJECT, UNDEFINED } from './constants';\nimport { shallowSerialize, sortObject } from './utils';\n\nconst cache = new Map<string, CacheEntry<any>>();\n\n/**\n * Generates a cache key for a given URL and fetch options, ensuring that key factors\n * like method, headers, body, and other options are included in the cache key.\n * Headers and other objects are sorted by key to ensure consistent cache keys.\n *\n * @param options - The fetch options that may affect the request. The most important are:\n *   @property {string} [method=\"GET\"] - The HTTP method (GET, POST, etc.).\n *   @property {HeadersInit} [headers={}] - The request headers.\n *   @property {BodyInit | null} [body=\"\"] - The body of the request (only for methods like POST, PUT).\n *   @property {RequestMode} [mode=\"cors\"] - The mode for the request (e.g., cors, no-cors, include).\n *   @property {RequestCredentials} [credentials=\"include\"] - Whether to include credentials like cookies.\n *   @property {RequestCache} [cache=\"default\"] - The cache mode (e.g., default, no-store, reload).\n *   @property {RequestRedirect} [redirect=\"follow\"] - How to handle redirects (e.g., follow, error, manual).\n *   @property {string} [referrer=\"\"] - The referrer URL to send with the request.\n *   @property {string} [integrity=\"\"] - Subresource integrity value (a cryptographic hash for resource validation).\n * @returns {string} - A unique cache key based on the URL and request options. Empty if cache is to be burst.\n *\n * @example\n * const cacheKey = generateCacheKey({\n *   url: 'https://api.example.com/data',\n *   method: 'POST',\n *   headers: { 'Content-Type': 'application/json' },\n *   body: JSON.stringify({ name: 'Alice' }),\n *   mode: 'cors',\n *   credentials: 'include',\n * });\n * console.log(cacheKey);\n */\nexport function generateCacheKey(options: FetcherConfig): string {\n  const {\n    url = '',\n    method = GET,\n    headers = {},\n    body = '',\n    mode = 'cors',\n    credentials = 'include',\n    cache = 'default',\n    redirect = 'follow',\n    referrer = '',\n    integrity = '',\n  } = options;\n\n  // Bail early if cache should be burst\n  if (cache === 'reload') {\n    return '';\n  }\n\n  // Sort headers and body + convert sorted to strings for hashing purposes\n  // Native serializer is on avg. 3.5x faster than a Fast Hash or FNV-1a\n  const headersString = shallowSerialize(sortObject(headers));\n\n  let bodyString = '';\n\n  // In majority of cases we do not cache body\n  if (body !== null) {\n    if (typeof body === 'string') {\n      bodyString = hash(body);\n    } else if (body instanceof FormData) {\n      body.forEach((value, key) => {\n        // Append key=value and '&' directly to the result\n        bodyString += key + '=' + value + '&';\n      });\n      bodyString = hash(bodyString);\n    } else if (\n      (typeof Blob !== UNDEFINED && body instanceof Blob) ||\n      (typeof File !== UNDEFINED && body instanceof File)\n    ) {\n      bodyString = 'BF' + body.size + body.type;\n    } else if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\n      bodyString = 'AB' + body.byteLength;\n    } else {\n      const o = typeof body === OBJECT ? sortObject(body) : String(body);\n      bodyString = hash(JSON.stringify(o));\n    }\n  }\n\n  // Concatenate all key parts into a cache key string\n  // Template literals are apparently slower\n  return (\n    method +\n    url +\n    mode +\n    credentials +\n    cache +\n    redirect +\n    referrer +\n    integrity +\n    headersString +\n    bodyString\n  );\n}\n\n/**\n * Checks if the cache entry is expired based on its timestamp and the maximum stale time.\n *\n * @param {number} timestamp - The timestamp of the cache entry.\n * @param {number} maxStaleTime - The maximum stale time in seconds.\n * @returns {boolean} - Returns true if the cache entry is expired, false otherwise.\n */\nfunction isCacheExpired(timestamp: number, maxStaleTime: number): boolean {\n  if (!maxStaleTime) {\n    return false;\n  }\n\n  return Date.now() - timestamp > maxStaleTime * 1000;\n}\n\n/**\n * Retrieves a cache entry if it exists and is not expired.\n *\n * @param {string} key Cache key to utilize\n * @param {FetcherConfig} cacheTime - Maximum time to cache entry.\n * @returns {CacheEntry<T> | null} - The cache entry if it exists and is not expired, null otherwise.\n */\nexport function getCache<T>(\n  key: string,\n  cacheTime: number,\n): CacheEntry<T> | null {\n  const entry = cache.get(key);\n\n  if (entry) {\n    if (!isCacheExpired(entry.timestamp, cacheTime)) {\n      return entry;\n    }\n\n    cache.delete(key);\n  }\n\n  return null;\n}\n\n/**\n * Sets a new cache entry or updates an existing one.\n *\n * @param {string} key Cache key to utilize\n * @param {T} data - The data to be cached.\n * @param {boolean} isLoading - Indicates if the data is currently being fetched.\n */\nexport function setCache<T = unknown>(\n  key: string,\n  data: T,\n  isLoading: boolean = false,\n): void {\n  cache.set(key, {\n    data,\n    isLoading,\n    timestamp: Date.now(),\n  });\n}\n\n/**\n * Revalidates a cache entry by fetching fresh data and updating the cache.\n *\n * @param {string} key Cache key to utilize\n * @param {FetcherConfig} config - The request configuration object.\n * @returns {Promise<void>} - A promise that resolves when the revalidation is complete.\n */\nexport async function revalidate(\n  key: string,\n  config: FetcherConfig,\n): Promise<void> {\n  try {\n    // Fetch fresh data\n    const newData = await fetchf(config.url, {\n      ...config,\n      cache: 'reload',\n    });\n\n    setCache(key, newData);\n  } catch (error) {\n    console.error(`Error revalidating ${config.url}:`, error);\n\n    // Rethrow the error to forward it\n    throw error;\n  }\n}\n\n/**\n * Invalidates (deletes) a cache entry.\n *\n * @param {string} key Cache key to utilize\n */\nexport function deleteCache(key: string): void {\n  cache.delete(key);\n}\n\n/**\n * Mutates a cache entry with new data and optionally revalidates it.\n *\n * @param {string} key Cache key to utilize\n * @param {FetcherConfig} config - The request configuration object.\n * @param {T} newData - The new data to be cached.\n * @param {boolean} revalidateAfter - If true, triggers revalidation after mutation.\n */\nexport function mutate<T>(\n  key: string,\n  config: FetcherConfig,\n  newData: T,\n  revalidateAfter: boolean = false,\n): void {\n  setCache(key, newData);\n\n  if (revalidateAfter) {\n    revalidate(key, config);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  DefaultResponse,\n  RequestHandlerConfig,\n  RequestConfig,\n  Method,\n  RetryOptions,\n  FetchResponse,\n  ResponseError,\n  RequestHandlerReturnType,\n  CreatedCustomFetcherInstance,\n  FetcherConfig,\n  FetcherInstance,\n  Logger,\n} from './types/request-handler';\nimport type {\n  BodyPayload,\n  DefaultParams,\n  DefaultPayload,\n  DefaultUrlParams,\n  QueryParams,\n} from './types/api-handler';\nimport { applyInterceptor } from './interceptor-manager';\nimport { ResponseErr } from './response-error';\nimport {\n  appendQueryParams,\n  isJSONSerializable,\n  replaceUrlPathParams,\n  delayInvocation,\n  flattenData,\n  processHeaders,\n  deleteProperty,\n  isSearchParams,\n} from './utils';\nimport { addRequest, removeRequest } from './queue-manager';\nimport {\n  ABORT_ERROR,\n  APPLICATION_JSON,\n  CANCELLED_ERROR,\n  CONTENT_TYPE,\n  GET,\n  HEAD,\n  OBJECT,\n  STRING,\n  UNDEFINED,\n} from './constants';\nimport { parseResponseData } from './response-parser';\nimport { generateCacheKey, getCache, setCache } from './cache-manager';\n\nconst defaultConfig: RequestHandlerConfig = {\n  method: GET,\n  strategy: 'reject',\n  timeout: 30000,\n  dedupeTime: 1000,\n  defaultResponse: null,\n  headers: {\n    Accept: APPLICATION_JSON + ', text/plain, */*',\n    'Accept-Encoding': 'gzip, deflate, br',\n    [CONTENT_TYPE]: APPLICATION_JSON + ';charset=utf-8',\n  },\n  retry: {\n    delay: 1000,\n    maxDelay: 30000,\n    resetTimeout: true,\n    backoff: 1.5,\n\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n    retryOn: [\n      408, // Request Timeout\n      409, // Conflict\n      425, // Too Early\n      429, // Too Many Requests\n      500, // Internal Server Error\n      502, // Bad Gateway\n      503, // Service Unavailable\n      504, // Gateway Timeout\n    ],\n  },\n};\n\n/**\n * Create Request Handler\n *\n * @param {RequestHandlerConfig} config - Configuration object for the request handler\n * @returns {Object} An object with methods for handling requests\n */\nexport function createRequestHandler(\n  config: RequestHandlerConfig,\n): RequestHandlerReturnType {\n  const handlerConfig: RequestHandlerConfig = {\n    ...defaultConfig,\n    ...config,\n  };\n\n  /**\n   * Merges the specified property from the base configuration and the new configuration into the target configuration.\n   *\n   * @param {K} property - The property key to merge from the base and new configurations. Must be a key of RequestHandlerConfig.\n   * @param {RequestHandlerConfig} targetConfig - The configuration object that will receive the merged properties.\n   * @param {RequestHandlerConfig} baseConfig - The base configuration object that provides default values.\n   * @param {RequestHandlerConfig} newConfig - The new configuration object that contains user-specific settings to merge.\n   */\n  const mergeConfig = <K extends keyof RequestHandlerConfig>(\n    property: K,\n    targetConfig: RequestHandlerConfig,\n    baseConfig: RequestHandlerConfig,\n    newConfig: RequestHandlerConfig,\n  ) => {\n    if (newConfig[property]) {\n      targetConfig[property] = {\n        ...baseConfig[property],\n        ...newConfig[property],\n      };\n    }\n  };\n\n  mergeConfig('retry', handlerConfig, defaultConfig, config);\n  mergeConfig('headers', handlerConfig, defaultConfig, config);\n\n  /**\n   * Gets a configuration value from `reqConfig`, defaulting to `handlerConfig` if not present.\n   *\n   * @param {RequestConfig} reqConfig - Request configuration object.\n   * @param {keyof RequestConfig} name - Key of the configuration value.\n   * @returns {T} - The configuration value.\n   */\n  const getConfig = <T = unknown>(\n    reqConfig: RequestConfig,\n    name: keyof RequestConfig,\n  ): T => {\n    return typeof reqConfig[name] !== UNDEFINED\n      ? reqConfig[name]\n      : handlerConfig[name];\n  };\n\n  /**\n   * Immediately create instance of custom fetcher if it is defined\n   */\n  const customFetcher = getConfig<FetcherInstance>(config, 'fetcher');\n  const requestInstance = customFetcher?.create(handlerConfig) || null;\n\n  /**\n   * Get Provider Instance\n   *\n   * @returns {CreatedCustomFetcherInstance | null} Provider's instance\n   */\n  const getInstance = (): CreatedCustomFetcherInstance | null => {\n    return requestInstance;\n  };\n\n  /**\n   * Logs messages or errors using the configured logger's `warn` method.\n   *\n   * @param {RequestConfig} reqConfig - Request config passed when making the request\n   * @param {...(string | ResponseError<any>)} args - Messages or errors to log.\n   */\n  const logger = (\n    reqConfig: RequestConfig,\n    ...args: (string | ResponseError<any>)[]\n  ): void => {\n    const logger = getConfig<Logger>(reqConfig, 'logger');\n\n    if (logger?.warn) {\n      logger.warn(...args);\n    }\n  };\n\n  /**\n   * Build request configuration\n   *\n   * @param {string} url - Request url\n   * @param {RequestConfig} requestConfig - Request config passed when making the request\n   * @returns {RequestConfig} - Provider's instance\n   */\n  const buildConfig = (\n    url: string,\n    requestConfig: RequestConfig,\n  ): FetcherConfig => {\n    const method = getConfig<string>(\n      requestConfig,\n      'method',\n    ).toUpperCase() as Method;\n    const isGetAlikeMethod = method === GET || method === HEAD;\n\n    const dynamicUrl = replaceUrlPathParams(\n      url,\n      getConfig(requestConfig, 'urlPathParams'),\n    );\n\n    // The explicitly passed \"params\"\n    const explicitParams = getConfig<QueryParams>(requestConfig, 'params');\n\n    // The explicitly passed \"body\" or \"data\"\n    const explicitBodyData: BodyPayload =\n      getConfig(requestConfig, 'body') || getConfig(requestConfig, 'data');\n\n    // Final body data\n    let body: RequestConfig['data'];\n\n    // Only applicable for request methods 'PUT', 'POST', 'DELETE', and 'PATCH'\n    if (!isGetAlikeMethod) {\n      body = explicitBodyData;\n    }\n\n    // Native fetch compatible settings\n    const isWithCredentials = getConfig<boolean>(\n      requestConfig,\n      'withCredentials',\n    );\n\n    const credentials = isWithCredentials\n      ? 'include'\n      : getConfig<RequestCredentials>(requestConfig, 'credentials');\n\n    const urlPath = explicitParams\n      ? appendQueryParams(dynamicUrl, explicitParams)\n      : dynamicUrl;\n    const isFullUrl = urlPath.includes('://');\n    const baseURL = isFullUrl\n      ? ''\n      : getConfig<string>(requestConfig, 'baseURL') ||\n        getConfig<string>(requestConfig, 'apiUrl');\n\n    // Automatically stringify request body, if possible and when not dealing with strings\n    if (\n      body &&\n      typeof body !== STRING &&\n      !isSearchParams(body) &&\n      isJSONSerializable(body)\n    ) {\n      body = JSON.stringify(body);\n    }\n\n    return {\n      ...requestConfig,\n      credentials,\n      body,\n      method,\n\n      url: baseURL + urlPath,\n    };\n  };\n\n  /**\n   * Process global Request Error\n   *\n   * @param {ResponseError<ResponseData>} error      Error instance\n   * @param {RequestConfig<ResponseData>} requestConfig   Per endpoint request config\n   * @returns {Promise<void>}\n   */\n  const processError = async <ResponseData = DefaultResponse>(\n    error: ResponseError<ResponseData>,\n    requestConfig: RequestConfig<ResponseData>,\n  ): Promise<void> => {\n    if (!isRequestCancelled(error)) {\n      logger(requestConfig, 'API ERROR', error);\n    }\n\n    // Local interceptors\n    await applyInterceptor(error, requestConfig?.onError);\n\n    // Global interceptors\n    await applyInterceptor(error, handlerConfig?.onError);\n  };\n\n  /**\n   * Output default response in case of an error, depending on chosen strategy\n   *\n   * @param {ResponseError<ResponseData>} error - Error instance\n   * @param {FetchResponse<ResponseData> | null} response - Response. It may be \"null\" in case of request being aborted.\n   * @param {RequestConfig<ResponseData>} requestConfig - Per endpoint request config\n   * @returns {FetchResponse<ResponseData>} Response together with the error object\n   */\n  const outputErrorResponse = async <ResponseData = DefaultResponse>(\n    error: ResponseError,\n    response: FetchResponse<ResponseData> | null,\n    requestConfig: RequestConfig<ResponseData>,\n  ): Promise<any> => {\n    const _isRequestCancelled = isRequestCancelled(error);\n    const errorHandlingStrategy = getConfig<string>(requestConfig, 'strategy');\n    const rejectCancelled = getConfig<boolean>(\n      requestConfig,\n      'rejectCancelled',\n    );\n\n    // By default cancelled requests aren't rejected (softFail strategy)\n    if (!(_isRequestCancelled && !rejectCancelled)) {\n      // Hang the promise\n      if (errorHandlingStrategy === 'silent') {\n        await new Promise(() => null);\n      }\n      // Reject the promise\n      else if (errorHandlingStrategy === 'reject') {\n        return Promise.reject(error);\n      }\n    }\n\n    return outputResponse<ResponseData>(response, requestConfig, error);\n  };\n\n  /**\n   * Output error response depending on chosen strategy\n   *\n   * @param {ResponseError} error               Error instance\n   * @returns {boolean}                        True if request is aborted\n   */\n  const isRequestCancelled = (error: ResponseError): boolean => {\n    return error.name === ABORT_ERROR || error.name === CANCELLED_ERROR;\n  };\n\n  /**\n   * Handle Request depending on used strategy\n   *\n   * @param {string} url - Request url\n   * @param {RequestConfig} reqConfig - Request config\n   * @throws {ResponseError}\n   * @returns {Promise<FetchResponse<ResponseData>>} Response Data\n   */\n  const request = async <\n    ResponseData = DefaultResponse,\n    QueryParams = DefaultParams,\n    PathParams = DefaultUrlParams,\n    RequestBody = DefaultPayload,\n  >(\n    url: string,\n    reqConfig: RequestConfig<\n      ResponseData,\n      QueryParams,\n      PathParams,\n      RequestBody\n    > | null = null,\n  ): Promise<FetchResponse<ResponseData>> => {\n    const _reqConfig = reqConfig || {};\n    const mergedConfig = {\n      ...handlerConfig,\n      ..._reqConfig,\n    } as RequestConfig;\n\n    mergeConfig('retry', mergedConfig, handlerConfig, _reqConfig);\n    mergeConfig('headers', mergedConfig, handlerConfig, _reqConfig);\n\n    let response: FetchResponse<ResponseData> | null = null;\n    const fetcherConfig = buildConfig(url, mergedConfig);\n\n    const {\n      timeout,\n      cancellable,\n      dedupeTime,\n      pollingInterval,\n      shouldStopPolling,\n      cacheTime,\n      cacheKey,\n    } = mergedConfig;\n\n    // Prevent performance overhead of cache access\n    let _cacheKey: string;\n\n    if (cacheKey) {\n      _cacheKey = cacheKey(fetcherConfig);\n    } else {\n      _cacheKey = generateCacheKey(fetcherConfig);\n    }\n\n    if (cacheTime && _cacheKey) {\n      const cacheBuster = mergedConfig.cacheBuster;\n\n      if (!cacheBuster || !cacheBuster(fetcherConfig)) {\n        const cachedEntry = getCache<FetchResponse<ResponseData>>(\n          _cacheKey,\n          cacheTime,\n        );\n\n        if (cachedEntry) {\n          // Serve stale data from cache\n          return cachedEntry.data;\n        }\n      }\n    }\n\n    const {\n      retries = 0,\n      delay,\n      backoff,\n      retryOn,\n      shouldRetry,\n      maxDelay,\n      resetTimeout,\n    } = mergedConfig.retry as Required<RetryOptions>;\n\n    let attempt = 0;\n    let pollingAttempt = 0;\n    let waitTime: number = delay;\n    const _retries = retries > 0 ? retries : 0;\n\n    while (attempt <= _retries) {\n      try {\n        // Add the request to the queue. Make sure to handle deduplication, cancellation, timeouts in accordance to retry settings\n        const controller = await addRequest(\n          fetcherConfig,\n          timeout,\n          dedupeTime,\n          cancellable,\n          // Reset timeouts by default or when retries are ON\n          !!(timeout && (!_retries || resetTimeout)),\n        );\n\n        // Shallow copy to ensure basic idempotency\n        const requestConfig: RequestConfig = {\n          signal: controller.signal,\n          ...fetcherConfig,\n        };\n\n        // Local interceptors\n        await applyInterceptor(requestConfig, _reqConfig?.onRequest);\n\n        // Global interceptors\n        await applyInterceptor(requestConfig, handlerConfig?.onRequest);\n\n        if (customFetcher !== null && requestInstance !== null) {\n          response = await requestInstance.request(requestConfig);\n        } else {\n          response = (await fetch(\n            requestConfig.url as string,\n            requestConfig as RequestInit,\n          )) as FetchResponse<ResponseData>;\n        }\n\n        // Add more information to response object\n        if (response instanceof Response) {\n          response.config = requestConfig;\n          response.data = await parseResponseData(response);\n\n          // Check if the response status is not outside the range 200-299 and if so, output error\n          if (!response.ok) {\n            throw new ResponseErr(\n              `${requestConfig.url} failed! Status: ${response.status || null}`,\n              requestConfig,\n              response,\n            );\n          }\n        }\n\n        // Local interceptors\n        await applyInterceptor(response, _reqConfig?.onResponse);\n\n        // Global interceptors\n        await applyInterceptor(response, handlerConfig?.onResponse);\n\n        removeRequest(fetcherConfig);\n\n        // Polling logic\n        if (\n          pollingInterval &&\n          (!shouldStopPolling || !shouldStopPolling(response, pollingAttempt))\n        ) {\n          // Restart the main retry loop\n          pollingAttempt++;\n\n          logger(requestConfig, 'Polling attempt ' + pollingAttempt + '...');\n\n          await delayInvocation(pollingInterval);\n\n          continue;\n        }\n\n        // If polling is not required, or polling attempts are exhausted\n        const output = outputResponse<ResponseData>(response, requestConfig);\n\n        if (cacheTime && _cacheKey) {\n          const skipCache = requestConfig.skipCache;\n\n          if (!skipCache || !skipCache(output, requestConfig)) {\n            setCache(_cacheKey, output);\n          }\n        }\n\n        return output;\n      } catch (err) {\n        const error = err as ResponseErr;\n        const status = error?.response?.status || error?.status || 0;\n\n        if (\n          attempt === retries ||\n          !(!shouldRetry || (await shouldRetry(error, attempt))) ||\n          !retryOn?.includes(status)\n        ) {\n          await processError<ResponseData>(error, fetcherConfig);\n\n          removeRequest(fetcherConfig);\n\n          return outputErrorResponse<ResponseData>(\n            error,\n            response,\n            fetcherConfig,\n          );\n        }\n\n        logger(\n          mergedConfig,\n          `Attempt ${attempt + 1} failed. Retry in ${waitTime}ms.`,\n        );\n\n        await delayInvocation(waitTime);\n\n        waitTime *= backoff;\n        waitTime = Math.min(waitTime, maxDelay);\n        attempt++;\n      }\n    }\n\n    return outputResponse<ResponseData>(response, fetcherConfig);\n  };\n\n  /**\n   * Output response\n   *\n   * @param Response. It may be \"null\" in case of request being aborted.\n   * @param {RequestConfig} requestConfig - Request config\n   * @param error - whether the response is erroneous\n   * @returns {FetchResponse<ResponseData>} Response data\n   */\n  const outputResponse = <ResponseData = DefaultResponse>(\n    response: FetchResponse<ResponseData> | null,\n    requestConfig: RequestConfig<ResponseData>,\n    error: ResponseError<ResponseData> | null = null,\n  ): FetchResponse<ResponseData> => {\n    const defaultResponse = getConfig<any>(requestConfig, 'defaultResponse');\n\n    // This may happen when request is cancelled.\n    if (!response) {\n      return {\n        ok: false,\n        // Enhance the response with extra information\n        error,\n        data: defaultResponse,\n        headers: null,\n        config: requestConfig,\n      } as unknown as FetchResponse<ResponseData>;\n    }\n\n    // Clean up the error object\n    deleteProperty(error, 'response');\n    deleteProperty(error, 'request');\n    deleteProperty(error, 'config');\n\n    let data = response?.data;\n\n    // Set the default response if the provided data is an empty object\n    if (\n      data === undefined ||\n      data === null ||\n      (typeof data === OBJECT && Object.keys(data).length === 0)\n    ) {\n      data = defaultResponse;\n    }\n\n    // Return flattened response immediately\n    const flattenResponse = getConfig<boolean>(\n      requestConfig,\n      'flattenResponse',\n    );\n\n    if (flattenResponse) {\n      response.data = flattenData(data);\n    }\n\n    // If it's a custom fetcher, and it does not return any Response instance, it may have its own internal handler\n    if (!(response instanceof Response)) {\n      return response;\n    }\n\n    // Native fetch Response extended by extra information\n    return {\n      body: response.body,\n      bodyUsed: response.bodyUsed,\n      formData: response.formData,\n      ok: response.ok,\n      redirected: response.redirected,\n      type: response.type,\n      url: response.url,\n      status: response.status,\n      statusText: response.statusText,\n\n      blob: response.blob.bind(response),\n      json: response.json.bind(response),\n      text: response.text.bind(response),\n      clone: response.clone.bind(response),\n      arrayBuffer: response.arrayBuffer.bind(response),\n\n      // Enhance the response with extra information\n      error,\n      data,\n      headers: processHeaders(response.headers),\n      config: requestConfig,\n    };\n  };\n\n  return {\n    getInstance,\n    buildConfig,\n    config,\n    request,\n  };\n}\n","import type {\n  RequestConfig,\n  FetchResponse,\n  DefaultResponse,\n  CreatedCustomFetcherInstance,\n} from './types/request-handler';\nimport type {\n  ApiHandlerConfig,\n  ApiHandlerDefaultMethods,\n  ApiHandlerMethods,\n  DefaultPayload,\n  FallbackValue,\n  FinalParams,\n  FinalResponse,\n  QueryParams,\n  RequestConfigUrlRequired,\n  UrlPathParams,\n} from './types/api-handler';\nimport { createRequestHandler } from './request-handler';\n\n/**\n * Creates an instance of API Handler.\n * It creates an API fetcher function using native fetch() or a custom fetcher if it is passed as \"fetcher\".\n * @url https://github.com/MattCCC/fetchff\n *\n * @param {Object} config - Configuration object for the API fetcher.\n * @param {string} config.apiUrl - The base URL for the API.\n * @param {Object} config.endpoints - An object containing endpoint definitions.\n * @param {number} config.timeout - You can set the timeout for particular request in milliseconds.\n * @param {number} config.cancellable - If true, the ongoing previous requests will be automatically cancelled.\n * @param {number} config.rejectCancelled - If true and request is set to cancellable, a cancelled request promise will be rejected. By default, instead of rejecting the promise, defaultResponse is returned.\n * @param {number} config.timeout - Request timeout\n * @param {number} config.dedupeTime - Time window, in milliseconds, during which identical requests are deduplicated (treated as single request).\n * @param {string} config.strategy - Error Handling Strategy\n * @param {string} config.flattenResponse - Whether to flatten response \"data\" object within \"data\". It works only if the response structure includes a single data property.\n * @param {*} config.defaultResponse - Default response when there is no data or when endpoint fails depending on the chosen strategy. It's \"null\" by default\n * @param {Object} [config.retry] - Options for retrying requests.\n * @param {number} [config.retry.retries=0] - Number of retry attempts. No retries by default.\n * @param {number} [config.retry.delay=1000] - Initial delay between retries in milliseconds.\n * @param {number} [config.retry.backoff=1.5] - Exponential backoff factor.\n * @param {number[]} [config.retry.retryOn=[502, 504, 408]] - HTTP status codes to retry on.\n * @param {RequestInterceptor|RequestInterceptor[]} [config.onRequest] - Optional request interceptor function or an array of functions.\n * These functions will be called with the request configuration object before the request is made. Can be used to modify or log the request configuration.\n * @param {ResponseInterceptor|ResponseInterceptor[]} [config.onResponse] - Optional response interceptor function or an array of functions.\n * These functions will be called with the response object after the response is received. an be used to modify or log the response data.\n * @param {Function} [config.onError] - Optional callback function for handling errors.\n * @param {Object} [config.headers] - Optional default headers to include in every request.\n * @param {Object} config.fetcher - The Custom Fetcher instance to use for making requests. It should expose create() and request() functions.\n * @param {*} config.logger - Instance of custom logger. Either class or an object similar to \"console\". Console is used by default.\n * @returns API handler functions and endpoints to call\n *\n * @example\n * // Define endpoint paths\n * const endpoints = {\n *   getUser: '/user',\n *   createPost: '/post',\n * };\n *\n * // Create the API fetcher with configuration\n * const api = createApiFetcher({\n *   endpoints,\n *   apiUrl: 'https://example.com/api',\n *   onError(error) {\n *     console.log('Request failed', error);\n *   },\n *   headers: {\n *     'my-auth-key': 'example-auth-key-32rjjfa',\n *   },\n * });\n *\n * // Fetch user data\n * const response = await api.getUser({ userId: 1, ratings: [1, 2] })\n */\nfunction createApiFetcher<\n  EndpointsMethods extends object,\n  EndpointsSettings = never,\n>(config: ApiHandlerConfig<EndpointsMethods>) {\n  const endpoints = config.endpoints;\n  const requestHandler = createRequestHandler(config);\n\n  /**\n   * Get Custom Fetcher Provider Instance\n   *\n   * @returns {CreatedCustomFetcherInstance | null} Request Handler's Custom Fetcher Instance\n   */\n  function getInstance(): CreatedCustomFetcherInstance | null {\n    return requestHandler.getInstance();\n  }\n\n  /**\n   * Triggered when trying to use non-existent endpoints\n   *\n   * @param endpointName Endpoint Name\n   * @returns {Promise}\n   */\n  function handleNonImplemented(endpointName: string): Promise<null> {\n    console.error(`Add ${endpointName} to 'endpoints'.`);\n\n    return Promise.resolve(null);\n  }\n\n  /**\n   * Handle Single API Request\n   * It considers settings in following order: per-request settings, global per-endpoint settings, global settings.\n   *\n   * @param {keyof EndpointsMethods | string} endpointName - The name of the API endpoint to call.\n   * @param {EndpointConfig} [requestConfig={}] - Additional configuration for the request.\n   * @returns {Promise<FetchResponse<ResponseData>>} - A promise that resolves with the response from the API provider.\n   */\n  async function request<\n    ResponseData = never,\n    QueryParams_ = never,\n    UrlParams = never,\n    RequestBody = never,\n  >(\n    endpointName: keyof EndpointsMethods | string,\n    requestConfig: RequestConfig<\n      FinalResponse<ResponseData, DefaultResponse>,\n      FinalParams<ResponseData, QueryParams_, QueryParams>,\n      FinalParams<ResponseData, UrlParams, UrlPathParams>,\n      FallbackValue<ResponseData, DefaultPayload, RequestBody>\n    > = {},\n  ): Promise<FetchResponse<FinalResponse<ResponseData, DefaultResponse>>> {\n    // Use global per-endpoint settings\n    const endpointConfig =\n      endpoints[endpointName] ||\n      ({ url: endpointName as string } as RequestConfigUrlRequired);\n\n    const responseData = await requestHandler.request<\n      FinalResponse<ResponseData, DefaultResponse>,\n      FinalParams<ResponseData, QueryParams_, QueryParams>,\n      FinalParams<ResponseData, UrlParams, UrlParams>,\n      FallbackValue<ResponseData, DefaultPayload, RequestBody>\n    >(endpointConfig.url, {\n      ...endpointConfig,\n      ...requestConfig,\n    });\n\n    return responseData;\n  }\n\n  const apiHandler: ApiHandlerDefaultMethods<EndpointsMethods> = {\n    config,\n    endpoints,\n    requestHandler,\n    getInstance,\n    request,\n  };\n\n  /**\n   * Maps all API requests using native Proxy\n   *\n   * @param {*} prop          Caller\n   */\n  return new Proxy<ApiHandlerMethods<EndpointsMethods, EndpointsSettings>>(\n    apiHandler as ApiHandlerMethods<EndpointsMethods, EndpointsSettings>,\n    {\n      get(_target, prop: string) {\n        if (prop in apiHandler) {\n          return apiHandler[prop as unknown as keyof typeof apiHandler];\n        }\n\n        // Prevent handler from triggering non-existent endpoints\n        if (endpoints[prop]) {\n          return apiHandler.request.bind(null, prop);\n        }\n\n        return handleNonImplemented.bind(null, prop);\n      },\n    },\n  );\n}\n\nexport { createApiFetcher };\n","import { createRequestHandler } from './request-handler';\nimport type {\n  DefaultResponse,\n  FetchResponse,\n  RequestHandlerConfig,\n} from './types';\n\n/**\n * Simple wrapper for request fetching.\n * It abstracts the creation of RequestHandler, making it easy to perform API requests.\n *\n * @param {string | URL | globalThis.Request} url - Request URL.\n * @param {RequestHandlerConfig} config - Configuration object for the request handler.\n * @returns {Promise<FetchResponse<ResponseData>>} Response Data.\n */\nexport async function fetchf<ResponseData = DefaultResponse>(\n  url: string,\n  config: RequestHandlerConfig<ResponseData> = {},\n): Promise<FetchResponse<ResponseData>> {\n  return createRequestHandler(config).request<ResponseData>(url, config);\n}\n\nexport * from './types';\nexport * from './api-handler';\n"],"mappings":"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","names":["applyInterceptor","object","interceptors","value","interceptor","ResponseErr","message","requestInfo","response","__publicField","APPLICATION_CONTENT_TYPE","APPLICATION_JSON","CONTENT_TYPE","UNDEFINED","OBJECT","STRING","ABORT_ERROR","TIMEOUT_ERROR","CANCELLED_ERROR","GET","HEAD","isSearchParams","data","shallowSerialize","obj","result","key","sortObject","sortedObj","keys","i","len","appendQueryStringToUrl","baseUrl","queryString","appendQueryParams","url","params","isSearchParams","encodedQueryString","s","encode","add","k","v","buildParams","prefix","OBJECT","replaceUrlPathParams","urlPathParams","str","word","isJSONSerializable","value","UNDEFINED","STRING","proto","delayInvocation","ms","resolve","flattenData","data","processHeaders","headers","headersObject","deleteProperty","property","queue","addRequest","config","timeout","dedupeTime","isCancellable","isTimeoutEnabled","now","item","previousController","timeoutId","ABORT_ERROR","controller","error","TIMEOUT_ERROR","removeRequest","parseResponseData","response","_a","contentType","CONTENT_TYPE","data","APPLICATION_JSON","APPLICATION_CONTENT_TYPE","_e","_error","hash","str","i","len","char","cache","generateCacheKey","options","url","method","GET","headers","body","mode","credentials","redirect","referrer","integrity","headersString","shallowSerialize","sortObject","bodyString","hash","value","key","UNDEFINED","o","OBJECT","isCacheExpired","timestamp","maxStaleTime","getCache","cacheTime","entry","setCache","data","isLoading","defaultConfig","GET","APPLICATION_JSON","CONTENT_TYPE","createRequestHandler","config","handlerConfig","mergeConfig","property","targetConfig","baseConfig","newConfig","getConfig","reqConfig","name","UNDEFINED","customFetcher","requestInstance","getInstance","logger","args","buildConfig","url","requestConfig","method","isGetAlikeMethod","HEAD","dynamicUrl","replaceUrlPathParams","explicitParams","explicitBodyData","body","credentials","urlPath","appendQueryParams","baseURL","STRING","isSearchParams","isJSONSerializable","processError","error","isRequestCancelled","applyInterceptor","outputErrorResponse","response","_isRequestCancelled","errorHandlingStrategy","rejectCancelled","outputResponse","ABORT_ERROR","CANCELLED_ERROR","request","_a","_reqConfig","mergedConfig","fetcherConfig","timeout","cancellable","dedupeTime","pollingInterval","shouldStopPolling","cacheTime","cacheKey","_cacheKey","generateCacheKey","cacheBuster","cachedEntry","getCache","retries","delay","backoff","retryOn","shouldRetry","maxDelay","resetTimeout","attempt","pollingAttempt","waitTime","_retries","addRequest","parseResponseData","ResponseErr","removeRequest","delayInvocation","output","skipCache","setCache","err","status","defaultResponse","deleteProperty","data","OBJECT","flattenData","processHeaders","createApiFetcher","config","endpoints","requestHandler","createRequestHandler","getInstance","handleNonImplemented","endpointName","request","requestConfig","endpointConfig","apiHandler","_target","prop","fetchf","url","config","createRequestHandler"]}